Time	Sum	Command
5100	12902	> builtin source /usr/share/fish/config.fish
159	159	-> set -g IFS \n\ \t
53	53	-> set -qg __fish_added_user_paths
60	60	-> set -g __fish_added_user_paths
18	63	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
45	45	--> not set -q __fish_initialized
30	30	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
33	791	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
47	47	--> status --is-interactive
53	711	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
43	43	---> not set -q STY
112	112	---> not string match -q -- 'eterm*' $TERM
51	381	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
43	43	----> set -q KONSOLE_PROFILE_NAME
76	76	----> string match -q -- "*:*" $ITERM_SESSION_ID
72	72	----> string match -q -- "st-*" $TERM
139	139	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
44	44	---> set -q fish_term24bit
78	78	---> set -g fish_term24bit 1
55	55	-> set -l __extra_completionsdir
49	49	-> set -l __extra_functionsdir
48	48	-> set -l __extra_confdir
38	708	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
97	97	--> test -f $__fish_data_dir/__fish_build_paths.fish
395	573	--> source $__fish_data_dir/__fish_build_paths.fish
71	71	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
56	56	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
51	51	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
52	52	-> set -l xdg_data_dirs
42	1160	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
39	39	--> set -q XDG_DATA_DIRS
85	85	--> set --path xdg_data_dirs $XDG_DATA_DIRS
648	994	--> set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
346	346	---> string replace -r '([^/])/$' '$1' -- $xdg_data_dirs
121	121	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
106	106	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
100	100	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
18	149	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
131	131	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
14	118	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
104	104	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
8	66	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
58	58	--> not contains -- $__extra_confdir $vendor_confdirs
21	149	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
29	29	--> not set -q fish_function_path
99	99	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
24	142	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
26	26	--> not set -q fish_complete_path
92	92	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
26	26	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
6	99	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
19	93	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
31	31	---> not set -q FISH_UNIT_TESTS_RUNNING
43	43	---> test -d /usr/xpg4/bin
34	34	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
51	51	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
17	17	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
459	2136	-> __fish_set_locale
1262	1284	--> source /usr/share/fish/functions/__fish_set_locale.fish
22	22	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
53	53	--> set -l LOCALE_VARS
47	47	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
88	88	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
48	48	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
72	157	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
18	85	---> if set -q $locale_var
            return 0
        ...
38	38	----> set -q $locale_var
29	29	----> return 0
40	40	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
10	62	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
52	52	--> test $__fish_initialized -lt 2300
7	34	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
27	27	--> status --is-login
73	339	-> __fish_reconstruct_path
74	74	--> set -l local_path $PATH
48	48	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
35	35	--> set -g __fish_added_user_paths
8	31	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
23	23	---> set -q fish_user_paths
78	78	--> set -xg PATH $local_path
14	14	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
45	124	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
27	27	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
16	16	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
17	17	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
19	19	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
48	48	-> set -l sourcelist
591	591	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
158	158	> builtin source /etc/fish/config.fish
221	235	> source /usr/share/fish/functions/fish_title.fish
14	14	-> function fish_title
    # emacs is basically the only term that can't handle it.
    if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    end
...
86	5631	> fish_title
36	5545	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
872	5459	--> echo (status current-command) (__fish_pwd)
53	53	---> status current-command
504	4534	---> __fish_pwd
329	3866	----> source /usr/share/fish/functions/__fish_pwd.fish
383	3537	-----> switch (uname)
    case 'CYGWIN_*'
        function __fish_pwd --description "Show current path"
            pwd | sed -e 's-^/cygdrive/\(.\)/\?-\u\1:/-'
        end
    case '*'
        function __fish_pwd --description "Show current path"
            pwd
        end
...
3108	3108	------> uname
46	46	------> function __fish_pwd --description "Show current path"
            pwd
        ...
164	164	----> pwd
1871	1906	> source /home/spider/.config/fish/functions/fish_prompt.fish
35	35	-> function fish_prompt
	set -l __last_command_exit_status $status

    if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    end

    set -l cyan (set_color -o cyan)
    set -l yellow (set_color -o yellow)
    set -l red (set_color -o red)
    set -l green (set_color -o green)
    set -l blue (set_color -o blue)
    set -l normal (set_color normal)

    set -l arrow_color "$green"
    if test $__last_command_exit_status != 0
        set arrow_color "$red"
    end

    set -l arrow "$arrow_color➜ "
    if test "$USER" = 'root'
        set arrow "$arrow_color# "
    end

    set -l cwd $cyan(basename (prompt_pwd))

    if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    end

    echo -n -s $arrow ' '$cwd $repo_info $normal ' '
...
92	29753	> __fish_on_interactive
795	29618	-> __fish_config_interactive
4903	4949	--> source /usr/share/fish/functions/__fish_config_interactive.fish
46	46	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
10	90	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
80	80	---> test $__fish_initialized -lt 3000
4	40	--> if set -q __fish_config_interactive_done
        return
    ...
36	36	---> set -q __fish_config_interactive_done
40	40	--> set -g __fish_config_interactive_done
32	32	--> set -g __fish_active_key_bindings
3	30	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
27	27	---> not set -q fish_greeting
3	26	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
23	23	---> set -q fish_private_mode
29	29	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
5	47	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
42	42	---> test $__fish_initialized -lt 3100
29	135	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
27	27	---> not set -q FISH_UNIT_TESTS_RUNNING
4	79	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
75	75	----> not test -d $__fish_user_data_dir/generated_completions
18	412	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
29	29	---> status --is-interactive
14	365	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
238	238	----> functions -q fish_greeting
40	40	----> test -n "$fish_greeting"
73	73	----> echo $fish_greeting
47	47	--> set -l varargs --on-variable fish_key_bindings
72	272	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
49	49	---> set -a varargs --on-variable fish_color_$var
39	39	---> set -a varargs --on-variable fish_color_$var
37	37	---> set -a varargs --on-variable fish_color_$var
37	37	---> set -a varargs --on-variable fish_color_$var
38	38	---> set -a varargs --on-variable fish_color_$var
82	82	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
25	434	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
40	40	---> test -d /etc/init.d
169	169	---> complete -x -p "/etc/init.d/*" -a start --description 'Start service'
54	54	---> complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
53	53	---> complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
48	48	---> complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
45	45	---> complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
39	39	--> complete -c [ --wraps test
36	36	--> complete -c ! --wraps not
626	1341	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
715	715	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
42	42	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
93	13032	--> __fish_reload_key_bindings
77	142	---> __init_uvar fish_key_bindings fish_default_key_bindings
8	65	----> if not set --query $argv[1]
            set --universal $argv
        ...
57	57	-----> not set --query $argv[1]
5	79	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
74	74	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
12	1842	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
447	1830	----> not functions -q "$fish_key_bindings"
1353	1383	-----> source /usr/share/fish/functions/fish_default_key_bindings.fish
30	30	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
96	96	---> set -g __fish_active_key_bindings "$fish_key_bindings"
37	37	---> set -g fish_bind_mode default
19	10559	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
45	45	----> test "$fish_key_bindings" = fish_default_key_bindings
210	10495	----> fish_default_key_bindings 2>/dev/null
8	197	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
154	154	------> contains -- -h $argv
35	35	------> contains -- --help $argv
20	234	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
30	30	------> not set -q argv[1]
133	133	------> bind --erase --all --preset
4	51	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
47	47	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
13	92	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
36	36	------> not contains -- -s $argv
43	43	------> set argv "-s" $argv
636	7997	-----> __fish_shared_key_bindings $argv
2605	2681	------> source /usr/share/fish/functions/__fish_shared_key_bindings.fish
35	35	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste \  'if set -q __fish_paste_quoted[1]; or string length -q -- (commandline -c); commandline -i " "; end'
...
25	25	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
9	9	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
7	7	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
11	103	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
56	56	-------> contains -- -h $argv
36	36	-------> contains -- --help $argv
52	52	------> bind --preset $argv \cy yank
43	43	------> bind --preset $argv \ey yank-pop
50	50	------> bind --preset $argv -k right forward-char
44	44	------> bind --preset $argv -k left backward-char
41	41	------> bind --preset $argv \e\[C forward-char
38	38	------> bind --preset $argv \e\[D backward-char
37	37	------> bind --preset $argv \eOC forward-char
36	36	------> bind --preset $argv \eOD backward-char
42	42	------> bind --preset $argv -k ppage beginning-of-history
43	43	------> bind --preset $argv -k npage end-of-history
40	40	------> bind --preset $argv \cx fish_clipboard_copy
37	37	------> bind --preset $argv \cv fish_clipboard_paste
37	37	------> bind --preset $argv \e cancel
36	36	------> bind --preset $argv \t complete
37	37	------> bind --preset $argv \cs pager-toggle-search
40	40	------> bind --preset $argv --key btab complete-and-search
42	42	------> bind --preset $argv \e\n "commandline -i \n"
39	39	------> bind --preset $argv \e\r "commandline -i \n"
44	44	------> bind --preset $argv -k down down-or-search
47	47	------> bind --preset $argv -k up up-or-search
40	40	------> bind --preset $argv \e\[A up-or-search
38	38	------> bind --preset $argv \e\[B down-or-search
36	36	------> bind --preset $argv \eOA up-or-search
37	37	------> bind --preset $argv \eOB down-or-search
45	45	------> bind --preset $argv -k sright forward-bigword
43	43	------> bind --preset $argv -k sleft backward-bigword
41	41	------> bind --preset $argv \e\eOC nextd-or-forward-word
39	39	------> bind --preset $argv \e\eOD prevd-or-backward-word
38	38	------> bind --preset $argv \e\e\[C nextd-or-forward-word
38	38	------> bind --preset $argv \e\e\[D prevd-or-backward-word
37	37	------> bind --preset $argv \eO3C nextd-or-forward-word
37	37	------> bind --preset $argv \eO3D prevd-or-backward-word
38	38	------> bind --preset $argv \e\[3C nextd-or-forward-word
38	38	------> bind --preset $argv \e\[3D prevd-or-backward-word
68	68	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
49	49	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
41	41	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
40	40	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
39	39	------> bind --preset $argv \e\eOA history-token-search-backward
39	39	------> bind --preset $argv \e\eOB history-token-search-forward
39	39	------> bind --preset $argv \e\e\[A history-token-search-backward
38	38	------> bind --preset $argv \e\e\[B history-token-search-forward
38	38	------> bind --preset $argv \eO3A history-token-search-backward
38	38	------> bind --preset $argv \eO3B history-token-search-forward
38	38	------> bind --preset $argv \e\[3A history-token-search-backward
38	38	------> bind --preset $argv \e\[3B history-token-search-forward
38	38	------> bind --preset $argv \e\[1\;3A history-token-search-backward
39	39	------> bind --preset $argv \e\[1\;3B history-token-search-forward
38	38	------> bind --preset $argv \e\[1\;9A history-token-search-backward
38	38	------> bind --preset $argv \e\[1\;9B history-token-search-forward
39	39	------> bind --preset $argv \e. history-token-search-backward
38	38	------> bind --preset $argv \el __fish_list_current_token
39	39	------> bind --preset $argv \ew __fish_whatis_current_token
44	44	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
38	38	------> bind --preset $argv \cc __fish_cancel_commandline
37	37	------> bind --preset $argv \cu backward-kill-line
37	37	------> bind --preset $argv \cw backward-kill-path-component
39	39	------> bind --preset $argv \e\[F end-of-line
39	39	------> bind --preset $argv \e\[H beginning-of-line
46	46	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
39	39	------> bind --preset $argv \cd delete-or-exit
38	38	------> bind --preset $argv \es __fish_prepend_sudo
42	42	------> bind --preset $argv -k f1 __fish_man_page
39	39	------> bind --preset $argv \eh __fish_man_page
40	40	------> bind --preset $argv \ep '__fish_paginate'
40	40	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
38	38	------> bind --preset $argv \ee edit_command_buffer
38	38	------> bind --preset $argv \ev edit_command_buffer
243	850	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
414	414	-------> bind --list-modes | string match -v paste
95	95	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
52	52	-------> bind --preset -M $mode \e\[O false
46	46	-------> bind --preset -M $mode \e\[\?1004h false
274	730	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
370	370	-------> bind --list-modes | string match -v paste
86	86	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
50	50	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
41	41	------> bind --preset -M paste "" self-insert
41	41	------> bind --preset -M paste \r "commandline -i \n"
43	43	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
42	42	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
42	42	------> bind --preset -M paste \  'if set -q __fish_paste_quoted[1]; or string length -q -- (commandline -c); commandline -i " "; end'
45	45	-----> bind --preset $argv "" self-insert
43	43	-----> bind --preset $argv " " self-insert expand-abbr
41	41	-----> bind --preset $argv \n execute
39	39	-----> bind --preset $argv \r execute
39	39	-----> bind --preset $argv \ck kill-line
40	40	-----> bind --preset $argv \eOC forward-char
37	37	-----> bind --preset $argv \eOD backward-char
37	37	-----> bind --preset $argv \e\[C forward-char
37	37	-----> bind --preset $argv \e\[D backward-char
44	44	-----> bind --preset $argv -k right forward-char
41	41	-----> bind --preset $argv -k left backward-char
45	45	-----> bind --preset $argv -k dc delete-char
43	43	-----> bind --preset $argv -k backspace backward-delete-char
40	40	-----> bind --preset $argv \x7f backward-delete-char
43	43	-----> bind --preset $argv \e\[1~ beginning-of-line
64	64	-----> bind --preset $argv \e\[3~ delete-char
52	52	-----> bind --preset $argv \e\[4~ end-of-line
84	84	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
68	68	-----> bind --preset $argv -k end end-of-line 2>/dev/null
49	49	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
42	42	-----> bind --preset $argv \ca beginning-of-line
39	39	-----> bind --preset $argv \ce end-of-line
38	38	-----> bind --preset $argv \ch backward-delete-char
38	38	-----> bind --preset $argv \cp up-or-search
38	38	-----> bind --preset $argv \cn down-or-search
38	38	-----> bind --preset $argv \cf forward-char
38	38	-----> bind --preset $argv \cb backward-char
39	39	-----> bind --preset $argv \ct transpose-chars
41	41	-----> bind --preset $argv \et transpose-words
40	40	-----> bind --preset $argv \eu upcase-word
39	39	-----> bind --preset $argv \ec capitalize-word
41	41	-----> bind --preset $argv \e\x7f backward-kill-word
40	40	-----> bind --preset $argv \e\b backward-kill-word
39	39	-----> bind --preset $argv \eb backward-word
39	39	-----> bind --preset $argv \ef forward-word
43	43	-----> bind --preset $argv \e\[1\;5C forward-word
43	43	-----> bind --preset $argv \e\[1\;5D backward-word
40	40	-----> bind --preset $argv \e\< beginning-of-buffer
41	41	-----> bind --preset $argv \e\> end-of-buffer
37	37	-----> bind --preset $argv \ed kill-word
41	41	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
6	184	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
178	178	----> functions --query fish_user_key_bindings >/dev/null
16	303	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
38	38	---> not set -q FISH_UNIT_TESTS_RUNNING
21	21	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
20	20	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
49	208	---> __fish_enable_bracketed_paste
159	159	----> printf "\e[?2004h"
6	38	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
32	32	---> set -q TMUX
36	36	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
22	966	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
296	409	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
113	113	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
34	34	---> function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        ...
53	501	---> __update_cwd_osc
6	64	----> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
29	29	-----> status --is-command-substitution
29	29	-----> set -q INSIDE_EMACS
311	384	----> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
73	73	-----> string escape --style=url $PWD
59	6264	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
489	4795	---> not type -q __fish_command_not_found_handler
2080	2131	----> source /usr/share/fish/functions/type.fish
51	51	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
60	60	----> set -q argv[1]
82	82	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
158	158	----> argparse -n type -x t,p,P $options -- $argv
6	38	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
32	32	-----> set -q _flag_help
34	34	----> set -l res 1
31	31	----> set -l mode normal
28	28	----> set -l multi no
29	29	----> set -l selection all
26	26	----> set -l short no
16	68	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	-----> set -q _flag_quiet
29	29	-----> set mode quiet
23	23	----> set -q _flag_all
22	22	----> set -q _flag_short
21	21	----> set -q _flag_no_functions
61	1520	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	-----> set -l found 0
21	845	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	------> test $selection != files
4	195	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
191	191	-------> functions -q -- $i
7	588	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
458	581	-------> contains -- $i (builtin -n)
123	123	--------> builtin -n
44	44	-----> set -l paths
14	432	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
41	41	------> test $multi != yes
198	377	------> set paths (command -s -- $i)
179	179	-------> command -s -- $i
28	28	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
9	79	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
38	38	------> test $found = 0
32	32	------> test $mode != quiet
35	35	----> return $res
35	35	---> set -l os
16	1156	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
45	45	----> test -r /etc/os-release
290	1095	----> set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
805	805	-----> string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " "
23	219	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
62	62	----> contains -- suse $os
36	36	----> contains -- sles $os
41	41	----> test -f /usr/libexec/pk-command-not-found
34	34	----> test -f /usr/lib/command-not-found
23	23	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            ...
61	61	--> set __fish_initialized 3100
43	43	-> functions -e __fish_on_interactive
203	230	> source /usr/share/fish/functions/fish_mode_prompt.fish
27	27	-> function fish_mode_prompt --description "Displays the current mode"
    # To reuse the mode indicator use this function instead
    fish_default_mode_prompt
...
63	1075	> fish_mode_prompt
397	1012	-> fish_default_mode_prompt
457	487	--> source /usr/share/fish/functions/fish_default_mode_prompt.fish
30	30	---> function fish_default_mode_prompt --description "Display the default mode for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    end
...
18	128	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
69	69	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
41	41	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
153	160060	> fish_prompt
66	66	-> set -l __last_command_exit_status $status
33	160	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
35	35	--> set -g __fish_robbyrussell_functions_defined
13	13	--> function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        ...
7	7	--> function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        ...
5	5	--> function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        ...
5	5	--> function _hg_branch_name
            echo (hg branch 2>/dev/null)
        ...
10	10	--> function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        ...
5	5	--> function _is_hg_repo
            fish_print_hg_root >/dev/null
        ...
6	6	--> function _repo_branch_name
            _$argv[1]_branch_name
        ...
5	5	--> function _is_repo_dirty
            _is_$argv[1]_dirty
        ...
5	5	--> function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        ...
288	469	-> set -l cyan (set_color -o cyan)
181	181	--> set_color -o cyan
296	363	-> set -l yellow (set_color -o yellow)
67	67	--> set_color -o yellow
318	378	-> set -l red (set_color -o red)
60	60	--> set_color -o red
256	313	-> set -l green (set_color -o green)
57	57	--> set_color -o green
256	305	-> set -l blue (set_color -o blue)
49	49	--> set_color -o blue
223	269	-> set -l normal (set_color normal)
46	46	--> set_color normal
46	46	-> set -l arrow_color "$green"
6	43	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
37	37	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
4	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
297	4761	-> set -l cwd $cyan(basename (prompt_pwd))
2788	4464	--> basename (prompt_pwd)
401	1676	---> prompt_pwd
430	457	----> source /usr/share/fish/functions/prompt_pwd.fish
27	27	-----> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
50	50	----> set -l options 'h/help'
57	57	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
22	22	----> set -q fish_prompt_pwd_dir_length
31	31	----> set -l fish_prompt_pwd_dir_length 1
43	43	----> set realhome ~
250	356	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
106	106	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
25	229	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
67	67	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
137	137	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	152626	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
338	9252	--> set -l repo_type (_repo_type)
61	8914	---> _repo_type
30	8853	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
37	1843	-----> _is_hg_repo
1167	1806	------> fish_print_hg_root >/dev/null
441	459	-------> source /usr/share/fish/functions/fish_print_hg_root.fish
18	18	--------> function fish_print_hg_root
    # If hg isn't installed, there's nothing we can do
    if not command -sq hg
        return 1
    end

    # Find an hg directory above $PWD
    # without calling `hg root` because that's too slow
    set -l root
    set -l dir (pwd -P)
    while test $dir != "/"
        if test -f $dir'/.hg/dirstate'
            echo $dir/.hg
            return 0
        end
        # Go up one directory
        set dir (string replace -r '[^/]*/?$' '' $dir)
    end

    return 1
...
21	180	-------> if not command -sq hg
        return 1
    ...
131	131	--------> not command -sq hg
28	28	--------> return 1
80	6863	-----> _is_git_repo
213	3015	------> type -q git
44	44	-------> set -q argv[1]
79	79	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
137	137	-------> argparse -n type -x t,p,P $options -- $argv
6	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
34	34	-------> set -l res 1
33	33	-------> set -l mode normal
29	29	-------> set -l multi no
32	32	-------> set -l selection all
28	28	-------> set -l short no
18	73	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
31	31	--------> set mode quiet
25	25	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
77	2154	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
58	1138	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
42	42	---------> test $selection != files
8	171	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
163	163	----------> functions -q -- $i
17	867	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
689	850	----------> contains -- $i (builtin -n)
161	161	-----------> builtin -n
67	67	--------> set -l paths
24	491	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
53	53	---------> test $multi != yes
290	414	---------> set paths (command -s -- $i)
124	124	----------> command -s -- $i
76	291	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
56	56	---------> set res 0
42	42	---------> set found 1
25	25	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
22	92	---------> if test $multi != yes
                continue
            ...
40	40	----------> test $multi != yes
30	30	----------> continue
11	58	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
47	47	---------> test $found = 0
54	54	-------> return $res
3768	3768	------> git rev-parse --git-dir >/dev/null 2>&1
89	89	-----> echo 'git'
28	28	-----> return 0
452	5443	--> set -l repo_branch $red(_repo_branch_name $repo_type)
87	4991	---> _repo_branch_name $repo_type
75	4904	----> _$argv[1]_branch_name
405	4204	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3799	3799	------> git symbolic-ref --quiet HEAD 2>/dev/null
29	625	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
46	46	------> set -q branch[1]
428	550	------> echo (string replace -r '^refs/heads/' '' $branch)
122	122	-------> string replace -r '^refs/heads/' '' $branch
79	79	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	137816	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
318	137759	---> [ (_is_repo_dirty $repo_type) ]
85	137441	----> _is_repo_dirty $repo_type
58	137356	-----> _is_$argv[1]_dirty
478	137298	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
136820	136820	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
17	17	---> set repo_info "$repo_info$dirty"
33	33	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
26	279	> fish_title
10	253	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
15	15	--> not set -q INSIDE_EMACS
173	228	--> echo (status current-command) (__fish_pwd)
17	17	---> status current-command
23	38	---> __fish_pwd
15	15	----> pwd
107	205	> __fish_disable_bracketed_paste clear
98	98	-> printf "\e[?2004l"
86	1131	> fish_title clear
31	1045	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
49	49	--> not set -q INSIDE_EMACS
740	965	--> echo (status current-command) (__fish_pwd)
56	56	---> status current-command
107	169	---> __fish_pwd
62	62	----> pwd
3213	3213	> clear
76	159	> __fish_enable_bracketed_paste
83	83	-> printf "\e[?2004h"
77	337	> fish_mode_prompt
102	260	-> fish_default_mode_prompt
26	158	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
88	88	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
44	44	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
234	186331	> fish_prompt
91	91	-> set -l __last_command_exit_status $status
9	48	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
39	39	--> not set -q -g __fish_robbyrussell_functions_defined
478	593	-> set -l cyan (set_color -o cyan)
115	115	--> set_color -o cyan
343	435	-> set -l yellow (set_color -o yellow)
92	92	--> set_color -o yellow
365	430	-> set -l red (set_color -o red)
65	65	--> set_color -o red
416	496	-> set -l green (set_color -o green)
80	80	--> set_color -o green
418	497	-> set -l blue (set_color -o blue)
79	79	--> set_color -o blue
313	382	-> set -l normal (set_color normal)
69	69	--> set_color normal
54	54	-> set -l arrow_color "$green"
8	51	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
43	43	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
6	53	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
47	47	--> test "$USER" = 'root'
388	5156	-> set -l cwd $cyan(basename (prompt_pwd))
3608	4768	--> basename (prompt_pwd)
140	1160	---> prompt_pwd
56	56	----> set -l options 'h/help'
78	78	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
42	42	----> set -l fish_prompt_pwd_dir_length 1
80	80	----> set realhome ~
358	507	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
149	149	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
22	195	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
60	60	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
113	113	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
44	177733	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
441	10654	--> set -l repo_type (_repo_type)
85	10213	---> _repo_type
45	10128	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
47	332	-----> _is_hg_repo
106	285	------> fish_print_hg_root >/dev/null
25	179	-------> if not command -sq hg
        return 1
    ...
124	124	--------> not command -sq hg
30	30	--------> return 1
93	9561	-----> _is_git_repo
204	5076	------> type -q git
38	38	-------> set -q argv[1]
76	76	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
155	155	-------> argparse -n type -x t,p,P $options -- $argv
6	42	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
36	36	--------> set -q _flag_help
37	37	-------> set -l res 1
32	32	-------> set -l mode normal
31	31	-------> set -l multi no
33	33	-------> set -l selection all
28	28	-------> set -l short no
18	72	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
30	30	--------> set mode quiet
24	24	-------> set -q _flag_all
21	21	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
78	4224	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
40	3009	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
44	44	---------> test $selection != files
6	65	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
59	59	----------> functions -q -- $i
23	2860	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
2704	2837	----------> contains -- $i (builtin -n)
133	133	-----------> builtin -n
65	65	--------> set -l paths
29	645	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
51	51	---------> test $multi != yes
374	565	---------> set paths (command -s -- $i)
191	191	----------> command -s -- $i
89	354	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
63	63	---------> set res 0
51	51	---------> set found 1
41	41	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
20	110	---------> if test $multi != yes
                continue
            ...
64	64	----------> test $multi != yes
26	26	----------> continue
8	42	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
34	34	---------> test $found = 0
38	38	-------> return $res
4392	4392	------> git rev-parse --git-dir >/dev/null 2>&1
147	147	-----> echo 'git'
43	43	-----> return 0
480	5799	--> set -l repo_branch $red(_repo_branch_name $repo_type)
123	5319	---> _repo_branch_name $repo_type
122	5196	----> _$argv[1]_branch_name
475	4458	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3983	3983	------> git symbolic-ref --quiet HEAD 2>/dev/null
35	616	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
45	45	------> set -q branch[1]
419	536	------> echo (string replace -r '^refs/heads/' '' $branch)
117	117	-------> string replace -r '^refs/heads/' '' $branch
78	78	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	161158	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
264	161102	---> [ (_is_repo_dirty $repo_type) ]
75	160838	----> _is_repo_dirty $repo_type
57	160763	-----> _is_$argv[1]_dirty
401	160706	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
160305	160305	-------> git status -s --ignore-submodules=dirty 2>/dev/null
26	26	---> set -l dirty "$yellow ✗"
17	17	---> set repo_info "$repo_info$dirty"
32	32	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
25	313	> fish_title
9	288	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
19	19	--> not set -q INSIDE_EMACS
204	260	--> echo (status current-command) (__fish_pwd)
17	17	---> status current-command
24	39	---> __fish_pwd
15	15	----> pwd
138	232	> __fish_disable_bracketed_paste 'ls -alF'
94	94	-> printf "\e[?2004l"
113	1150	> fish_title ls\ -alF
37	1037	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
53	53	--> not set -q INSIDE_EMACS
743	947	--> echo (status current-command) (__fish_pwd)
61	61	---> status current-command
86	143	---> __fish_pwd
57	57	----> pwd
640	17939	> ls -alF
787	5054	-> source /usr/share/fish/functions/ls.fish
78	4267	--> for opt in --color=auto -G --color -F
    if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    end
...
84	4189	---> if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    ...
3793	3793	----> command ls $opt / >/dev/null 2>/dev/null
82	82	----> function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        ...
32	196	----> if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        ...
80	80	-----> [ $opt = --color=auto ]
84	84	-----> ! set -qx LS_COLORS
34	34	----> break
791	4372	-> isatty stdout
559	601	--> source /usr/share/fish/functions/isatty.fish
42	42	---> function isatty -d "Tests if a file descriptor is a tty"
    set -l options 'h/help'
    argparse -n isatty $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help isatty
        return 0
    end

    if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    end

    set -l fd
    switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    end

    # Use `command test` because `builtin test` doesn't open the regular fd's.
    # See https://github.com/fish-shell/fish-shell/issues/1228
    # Too often `command test` is some bogus Go binary, I don't know why. Use [ because
    # it's less likely to be something surprising. See #5665
    command [ -t "$fd" ]
...
70	70	--> set -l options 'h/help'
71	71	--> argparse -n isatty $options -- $argv
12	42	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
30	30	---> set -q _flag_help
9	36	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
27	27	---> set -q argv[2]
32	32	--> set -l fd
40	73	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
33	33	---> set fd 1
2656	2656	--> command [ -t "$fd" ]
123	123	-> set -a opt -F
7750	7750	-> command ls $opt $argv
92	197	> __fish_enable_bracketed_paste
105	105	-> printf "\e[?2004h"
87	329	> fish_mode_prompt
91	242	-> fish_default_mode_prompt
22	151	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
90	90	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
39	39	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
191	184250	> fish_prompt
75	75	-> set -l __last_command_exit_status $status
7	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
458	543	-> set -l cyan (set_color -o cyan)
85	85	--> set_color -o cyan
354	446	-> set -l yellow (set_color -o yellow)
92	92	--> set_color -o yellow
370	435	-> set -l red (set_color -o red)
65	65	--> set_color -o red
364	445	-> set -l green (set_color -o green)
81	81	--> set_color -o green
412	478	-> set -l blue (set_color -o blue)
66	66	--> set_color -o blue
436	504	-> set -l normal (set_color normal)
68	68	--> set_color normal
62	62	-> set -l arrow_color "$green"
9	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
44	44	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
5	55	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
50	50	--> test "$USER" = 'root'
475	4655	-> set -l cwd $cyan(basename (prompt_pwd))
3022	4180	--> basename (prompt_pwd)
141	1158	---> prompt_pwd
54	54	----> set -l options 'h/help'
64	64	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	37	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
31	31	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
33	33	----> set -l fish_prompt_pwd_dir_length 1
55	55	----> set realhome ~
370	523	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
153	153	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
30	226	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
65	65	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
131	131	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
34	176189	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
473	9422	--> set -l repo_type (_repo_type)
112	8949	---> _repo_type
48	8837	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
76	500	-----> _is_hg_repo
156	424	------> fish_print_hg_root >/dev/null
41	268	-------> if not command -sq hg
        return 1
    ...
176	176	--------> not command -sq hg
51	51	--------> return 1
118	8090	-----> _is_git_repo
309	4003	------> type -q git
57	57	-------> set -q argv[1]
116	116	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
235	235	-------> argparse -n type -x t,p,P $options -- $argv
12	68	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
56	56	--------> set -q _flag_help
52	52	-------> set -l res 1
50	50	-------> set -l mode normal
46	46	-------> set -l multi no
47	47	-------> set -l selection all
44	44	-------> set -l short no
32	122	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
40	40	--------> set -q _flag_quiet
50	50	--------> set mode quiet
43	43	-------> set -q _flag_all
80	80	-------> set -q _flag_short
39	39	-------> set -q _flag_no_functions
105	2641	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
57	57	--------> set -l found 0
69	1297	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
64	64	---------> test $selection != files
10	99	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
89	89	----------> functions -q -- $i
14	1065	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
861	1051	----------> contains -- $i (builtin -n)
190	190	-----------> builtin -n
68	68	--------> set -l paths
32	704	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
65	65	---------> test $multi != yes
418	607	---------> set paths (command -s -- $i)
189	189	----------> command -s -- $i
85	346	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
58	58	---------> set res 0
49	49	---------> set found 1
37	37	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
27	117	---------> if test $multi != yes
                continue
            ...
58	58	----------> test $multi != yes
32	32	----------> continue
11	64	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
53	53	---------> test $found = 0
54	54	-------> return $res
3969	3969	------> git rev-parse --git-dir >/dev/null 2>&1
154	154	-----> echo 'git'
45	45	-----> return 0
420	5920	--> set -l repo_branch $red(_repo_branch_name $repo_type)
121	5500	---> _repo_branch_name $repo_type
109	5379	----> _$argv[1]_branch_name
524	4700	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4176	4176	------> git symbolic-ref --quiet HEAD 2>/dev/null
28	570	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
47	47	------> set -q branch[1]
373	495	------> echo (string replace -r '^refs/heads/' '' $branch)
122	122	-------> string replace -r '^refs/heads/' '' $branch
71	71	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
15	160742	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
338	160682	---> [ (_is_repo_dirty $repo_type) ]
71	160344	----> _is_repo_dirty $repo_type
60	160273	-----> _is_$argv[1]_dirty
537	160213	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
159676	159676	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
17	17	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
24	331	> fish_title
10	307	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
15	15	--> not set -q INSIDE_EMACS
220	282	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
30	47	---> __fish_pwd
17	17	----> pwd
139	249	> __fish_disable_bracketed_paste clear
110	110	-> printf "\e[?2004l"
76	1006	> fish_title clear
30	930	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
636	852	--> echo (status current-command) (__fish_pwd)
69	69	---> status current-command
89	147	---> __fish_pwd
58	58	----> pwd
3413	3413	> clear
94	242	> __fish_enable_bracketed_paste
148	148	-> printf "\e[?2004h"
122	383	> fish_mode_prompt
94	261	-> fish_default_mode_prompt
24	167	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
98	98	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
45	45	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
218	196241	> fish_prompt
94	94	-> set -l __last_command_exit_status $status
8	44	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
36	36	--> not set -q -g __fish_robbyrussell_functions_defined
555	656	-> set -l cyan (set_color -o cyan)
101	101	--> set_color -o cyan
461	554	-> set -l yellow (set_color -o yellow)
93	93	--> set_color -o yellow
475	565	-> set -l red (set_color -o red)
90	90	--> set_color -o red
423	518	-> set -l green (set_color -o green)
95	95	--> set_color -o green
384	463	-> set -l blue (set_color -o blue)
79	79	--> set_color -o blue
300	370	-> set -l normal (set_color normal)
70	70	--> set_color normal
54	54	-> set -l arrow_color "$green"
8	54	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
45	45	-> set -l arrow "$arrow_color➜ "
5	52	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
47	47	--> test "$USER" = 'root'
445	5686	-> set -l cwd $cyan(basename (prompt_pwd))
3250	5241	--> basename (prompt_pwd)
168	1991	---> prompt_pwd
55	55	----> set -l options 'h/help'
66	66	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	35	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
103	103	----> set -q fish_prompt_pwd_dir_length
62	62	----> set -l fish_prompt_pwd_dir_length 1
91	91	----> set realhome ~
908	1104	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
196	196	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
38	307	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
89	89	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
180	180	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
38	186834	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
440	8910	--> set -l repo_type (_repo_type)
84	8470	---> _repo_type
31	8386	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
49	335	-----> _is_hg_repo
107	286	------> fish_print_hg_root >/dev/null
26	179	-------> if not command -sq hg
        return 1
    ...
124	124	--------> not command -sq hg
29	29	--------> return 1
84	7877	-----> _is_git_repo
186	2860	------> type -q git
36	36	-------> set -q argv[1]
75	75	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
147	147	-------> argparse -n type -x t,p,P $options -- $argv
6	36	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
30	30	--------> set -q _flag_help
33	33	-------> set -l res 1
32	32	-------> set -l mode normal
28	28	-------> set -l multi no
30	30	-------> set -l selection all
27	27	-------> set -l short no
17	78	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
32	32	--------> set -q _flag_quiet
29	29	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
81	2049	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
48	980	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
6	62	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
19	829	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
681	810	----------> contains -- $i (builtin -n)
129	129	-----------> builtin -n
77	77	--------> set -l paths
28	587	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
53	53	---------> test $multi != yes
364	506	---------> set paths (command -s -- $i)
142	142	----------> command -s -- $i
70	251	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
43	43	---------> set res 0
36	36	---------> set found 1
26	26	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
16	76	---------> if test $multi != yes
                continue
            ...
37	37	----------> test $multi != yes
23	23	----------> continue
8	41	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
33	33	---------> test $found = 0
37	37	-------> return $res
4933	4933	------> git rev-parse --git-dir >/dev/null 2>&1
113	113	-----> echo 'git'
30	30	-----> return 0
375	5835	--> set -l repo_branch $red(_repo_branch_name $repo_type)
99	5460	---> _repo_branch_name $repo_type
96	5361	----> _$argv[1]_branch_name
438	4667	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4229	4229	------> git symbolic-ref --quiet HEAD 2>/dev/null
30	598	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
64	64	------> set -q branch[1]
344	504	------> echo (string replace -r '^refs/heads/' '' $branch)
160	160	-------> string replace -r '^refs/heads/' '' $branch
94	94	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
56	171957	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
329	171854	---> [ (_is_repo_dirty $repo_type) ]
73	171525	----> _is_repo_dirty $repo_type
56	171452	-----> _is_$argv[1]_dirty
450	171396	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
170946	170946	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
34	34	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
26	367	> fish_title
10	341	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
256	317	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
28	46	---> __fish_pwd
18	18	----> pwd
124	216	> __fish_disable_bracketed_paste 'ls -alF'
92	92	-> printf "\e[?2004l"
83	1146	> fish_title ls\ -alF
30	1063	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
53	53	--> not set -q INSIDE_EMACS
707	980	--> echo (status current-command) (__fish_pwd)
56	56	---> status current-command
111	217	---> __fish_pwd
106	106	----> pwd
330	10334	> ls -alF
308	4086	-> isatty stdout
70	70	--> set -l options 'h/help'
82	82	--> argparse -n isatty $options -- $argv
15	49	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
34	34	---> set -q _flag_help
11	44	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
33	33	---> set -q argv[2]
38	38	--> set -l fd
47	129	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
82	82	---> set fd 1
3366	3366	--> command [ -t "$fd" ]
86	86	-> set -a opt -F
5832	5832	-> command ls $opt $argv
140	250	> __fish_enable_bracketed_paste
110	110	-> printf "\e[?2004h"
85	313	> fish_mode_prompt
76	228	-> fish_default_mode_prompt
19	152	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
84	84	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
49	49	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
160	169914	> fish_prompt
89	89	-> set -l __last_command_exit_status $status
6	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
32	32	--> not set -q -g __fish_robbyrussell_functions_defined
368	458	-> set -l cyan (set_color -o cyan)
90	90	--> set_color -o cyan
280	346	-> set -l yellow (set_color -o yellow)
66	66	--> set_color -o yellow
259	316	-> set -l red (set_color -o red)
57	57	--> set_color -o red
231	289	-> set -l green (set_color -o green)
58	58	--> set_color -o green
223	280	-> set -l blue (set_color -o blue)
57	57	--> set_color -o blue
236	287	-> set -l normal (set_color normal)
51	51	--> set_color normal
49	49	-> set -l arrow_color "$green"
6	49	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
43	43	--> test $__last_command_exit_status != 0
43	43	-> set -l arrow "$arrow_color➜ "
6	53	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
47	47	--> test "$USER" = 'root'
435	7145	-> set -l cwd $cyan(basename (prompt_pwd))
5424	6710	--> basename (prompt_pwd)
148	1286	---> prompt_pwd
53	53	----> set -l options 'h/help'
68	68	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
59	59	----> set realhome ~
353	545	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
192	192	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
43	316	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
90	90	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
183	183	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
33	160277	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
384	8895	--> set -l repo_type (_repo_type)
86	8511	---> _repo_type
34	8425	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
48	385	-----> _is_hg_repo
109	337	------> fish_print_hg_root >/dev/null
63	228	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
31	31	--------> return 1
88	7876	-----> _is_git_repo
181	2795	------> type -q git
37	37	-------> set -q argv[1]
75	75	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
150	150	-------> argparse -n type -x t,p,P $options -- $argv
6	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
33	33	-------> set -l res 1
31	31	-------> set -l mode normal
28	28	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
17	69	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
29	29	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
71	1994	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
47	953	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
40	40	---------> test $selection != files
6	64	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
15	802	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
626	787	----------> contains -- $i (builtin -n)
161	161	-----------> builtin -n
56	56	--------> set -l paths
29	601	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
393	524	---------> set paths (command -s -- $i)
131	131	----------> command -s -- $i
63	243	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
47	47	---------> set res 0
32	32	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	78	---------> if test $multi != yes
                continue
            ...
41	41	----------> test $multi != yes
22	22	----------> continue
6	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
36	36	-------> return $res
4993	4993	------> git rev-parse --git-dir >/dev/null 2>&1
101	101	-----> echo 'git'
29	29	-----> return 0
364	5562	--> set -l repo_branch $red(_repo_branch_name $repo_type)
89	5198	---> _repo_branch_name $repo_type
91	5109	----> _$argv[1]_branch_name
414	4374	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3960	3960	------> git symbolic-ref --quiet HEAD 2>/dev/null
30	644	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
46	46	------> set -q branch[1]
441	568	------> echo (string replace -r '^refs/heads/' '' $branch)
127	127	-------> string replace -r '^refs/heads/' '' $branch
85	85	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
20	145702	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
365	145635	---> [ (_is_repo_dirty $repo_type) ]
86	145270	----> _is_repo_dirty $repo_type
60	145184	-----> _is_$argv[1]_dirty
496	145124	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
144628	144628	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
26	311	> fish_title
11	285	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
16	16	--> not set -q INSIDE_EMACS
202	258	--> echo (status current-command) (__fish_pwd)
17	17	---> status current-command
23	39	---> __fish_pwd
16	16	----> pwd
120	221	> __fish_disable_bracketed_paste clear
101	101	-> printf "\e[?2004l"
91	1026	> fish_title clear
27	935	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
52	52	--> not set -q INSIDE_EMACS
641	856	--> echo (status current-command) (__fish_pwd)
65	65	---> status current-command
101	150	---> __fish_pwd
49	49	----> pwd
2954	2954	> clear
81	188	> __fish_enable_bracketed_paste
107	107	-> printf "\e[?2004h"
76	291	> fish_mode_prompt
78	215	-> fish_default_mode_prompt
18	137	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
79	79	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
40	40	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
195	196217	> fish_prompt
75	75	-> set -l __last_command_exit_status $status
6	40	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
361	441	-> set -l cyan (set_color -o cyan)
80	80	--> set_color -o cyan
1939	2001	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
955	1047	-> set -l red (set_color -o red)
92	92	--> set_color -o red
373	473	-> set -l green (set_color -o green)
100	100	--> set_color -o green
906	1006	-> set -l blue (set_color -o blue)
100	100	--> set_color -o blue
320	384	-> set -l normal (set_color normal)
64	64	--> set_color normal
61	61	-> set -l arrow_color "$green"
7	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
44	44	-> set -l arrow "$arrow_color➜ "
7	57	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
50	50	--> test "$USER" = 'root'
834	5421	-> set -l cwd $cyan(basename (prompt_pwd))
3428	4587	--> basename (prompt_pwd)
156	1159	---> prompt_pwd
72	72	----> set -l options 'h/help'
74	74	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	41	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
33	33	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
59	59	----> set realhome ~
346	492	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
146	146	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
29	204	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
61	61	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
114	114	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	184885	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
365	8272	--> set -l repo_type (_repo_type)
93	7907	---> _repo_type
35	7814	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
48	343	-----> _is_hg_repo
115	295	------> fish_print_hg_root >/dev/null
26	180	-------> if not command -sq hg
        return 1
    ...
125	125	--------> not command -sq hg
29	29	--------> return 1
82	6936	-----> _is_git_repo
190	2699	------> type -q git
40	40	-------> set -q argv[1]
77	77	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
160	160	-------> argparse -n type -x t,p,P $options -- $argv
7	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
33	33	-------> set -l res 1
33	33	-------> set -l mode normal
29	29	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
17	71	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
29	29	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
74	1825	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
46	894	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
7	65	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
15	742	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
585	727	----------> contains -- $i (builtin -n)
142	142	-----------> builtin -n
48	48	--------> set -l paths
22	523	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
42	42	---------> test $multi != yes
319	459	---------> set paths (command -s -- $i)
140	140	----------> command -s -- $i
54	216	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
41	41	---------> set res 0
30	30	---------> set found 1
21	21	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
14	70	---------> if test $multi != yes
                continue
            ...
35	35	----------> test $multi != yes
21	21	----------> continue
6	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
81	81	-------> return $res
4155	4155	------> git rev-parse --git-dir >/dev/null 2>&1
112	112	-----> echo 'git'
388	388	-----> return 0
412	6183	--> set -l repo_branch $red(_repo_branch_name $repo_type)
91	5771	---> _repo_branch_name $repo_type
95	5680	----> _$argv[1]_branch_name
469	4963	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4494	4494	------> git symbolic-ref --quiet HEAD 2>/dev/null
31	622	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
46	46	------> set -q branch[1]
425	545	------> echo (string replace -r '^refs/heads/' '' $branch)
120	120	-------> string replace -r '^refs/heads/' '' $branch
79	79	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
16	170315	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
276	170253	---> [ (_is_repo_dirty $repo_type) ]
75	169977	----> _is_repo_dirty $repo_type
57	169902	-----> _is_$argv[1]_dirty
398	169845	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
169447	169447	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
34	34	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
23	296	> fish_title
10	273	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
13	13	--> not set -q INSIDE_EMACS
197	250	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
23	38	---> __fish_pwd
15	15	----> pwd
157	258	> __fish_disable_bracketed_paste 'ls -alF'
101	101	-> printf "\e[?2004l"
100	1289	> fish_title ls\ -alF
43	1189	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
53	53	--> not set -q INSIDE_EMACS
806	1093	--> echo (status current-command) (__fish_pwd)
56	56	---> status current-command
142	231	---> __fish_pwd
89	89	----> pwd
374	12584	> ls -alF
328	4082	-> isatty stdout
70	70	--> set -l options 'h/help'
88	88	--> argparse -n isatty $options -- $argv
16	51	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
35	35	---> set -q _flag_help
12	45	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
33	33	---> set -q argv[2]
38	38	--> set -l fd
48	87	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
39	39	---> set fd 1
3375	3375	--> command [ -t "$fd" ]
96	96	-> set -a opt -F
8032	8032	-> command ls $opt $argv
126	263	> __fish_enable_bracketed_paste
137	137	-> printf "\e[?2004h"
105	386	> fish_mode_prompt
111	281	-> fish_default_mode_prompt
23	170	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
94	94	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
53	53	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
244	183114	> fish_prompt
128	128	-> set -l __last_command_exit_status $status
8	48	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
40	40	--> not set -q -g __fish_robbyrussell_functions_defined
434	537	-> set -l cyan (set_color -o cyan)
103	103	--> set_color -o cyan
468	558	-> set -l yellow (set_color -o yellow)
90	90	--> set_color -o yellow
407	489	-> set -l red (set_color -o red)
82	82	--> set_color -o red
358	445	-> set -l green (set_color -o green)
87	87	--> set_color -o green
390	472	-> set -l blue (set_color -o blue)
82	82	--> set_color -o blue
325	413	-> set -l normal (set_color normal)
88	88	--> set_color normal
63	63	-> set -l arrow_color "$green"
16	61	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
47	47	-> set -l arrow "$arrow_color➜ "
5	50	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
45	45	--> test "$USER" = 'root'
375	4081	-> set -l cwd $cyan(basename (prompt_pwd))
2585	3706	--> basename (prompt_pwd)
138	1121	---> prompt_pwd
52	52	----> set -l options 'h/help'
66	66	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	35	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
58	58	----> set realhome ~
358	495	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
137	137	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
24	218	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
64	64	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
130	130	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
37	175443	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
366	9652	--> set -l repo_type (_repo_type)
108	9286	---> _repo_type
36	9178	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
72	536	-----> _is_hg_repo
148	464	------> fish_print_hg_root >/dev/null
99	316	-------> if not command -sq hg
        return 1
    ...
171	171	--------> not command -sq hg
46	46	--------> return 1
109	8476	-----> _is_git_repo
303	3857	------> type -q git
57	57	-------> set -q argv[1]
112	112	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
213	213	-------> argparse -n type -x t,p,P $options -- $argv
11	59	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
48	48	--------> set -q _flag_help
51	51	-------> set -l res 1
50	50	-------> set -l mode normal
44	44	-------> set -l multi no
47	47	-------> set -l selection all
43	43	-------> set -l short no
32	159	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
36	36	--------> set -q _flag_quiet
91	91	--------> set mode quiet
44	44	-------> set -q _flag_all
36	36	-------> set -q _flag_short
33	33	-------> set -q _flag_no_functions
106	2551	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
54	54	--------> set -l found 0
63	1270	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
64	64	---------> test $selection != files
12	115	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
103	103	----------> functions -q -- $i
22	1028	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
818	1006	----------> contains -- $i (builtin -n)
188	188	-----------> builtin -n
69	69	--------> set -l paths
31	647	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
64	64	---------> test $multi != yes
361	552	---------> set paths (command -s -- $i)
191	191	----------> command -s -- $i
84	343	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
58	58	---------> set res 0
49	49	---------> set found 1
38	38	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
27	114	---------> if test $multi != yes
                continue
            ...
55	55	----------> test $multi != yes
32	32	----------> continue
13	62	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
49	49	---------> test $found = 0
55	55	-------> return $res
4510	4510	------> git rev-parse --git-dir >/dev/null 2>&1
101	101	-----> echo 'git'
29	29	-----> return 0
491	7104	--> set -l repo_branch $red(_repo_branch_name $repo_type)
122	6613	---> _repo_branch_name $repo_type
113	6491	----> _$argv[1]_branch_name
453	5812	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
5359	5359	------> git symbolic-ref --quiet HEAD 2>/dev/null
28	566	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
45	45	------> set -q branch[1]
369	493	------> echo (string replace -r '^refs/heads/' '' $branch)
124	124	-------> string replace -r '^refs/heads/' '' $branch
79	79	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
14	158571	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
318	158509	---> [ (_is_repo_dirty $repo_type) ]
82	158191	----> _is_repo_dirty $repo_type
59	158109	-----> _is_$argv[1]_dirty
417	158050	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
157633	157633	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
26	325	> fish_title
9	299	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
17	17	--> not set -q INSIDE_EMACS
217	273	--> echo (status current-command) (__fish_pwd)
17	17	---> status current-command
23	39	---> __fish_pwd
16	16	----> pwd
11991	16262	> source /usr/share/fish/completions/rm.fish
111	4271	-> if rm --version >/dev/null 2>/dev/null # GNU
    complete -c rm -s d -l directory -d "Unlink directories"
    complete -c rm -s f -l force -d "Never prompt for removal"
    complete -c rm -s i -l interactive -d "Prompt for removal"
    complete -c rm -s I -d "Prompt to remove >3 files"
    complete -c rm -s r -l recursive -d "Recursively remove subdirs"
    complete -c rm -s R -d "Recursively remove subdirs"
    complete -c rm -s v -l verbose -d "Explain what is done"
    complete -c rm -s h -l help -d "Display help"
    complete -c rm -l version -d "Display rm version"
else
    set -l uname (uname -s)
    # solaris:   rm [-fi        ] file ...
    # openbsd:   rm [-fidPRrv   ] file ...
    # macos:     rm [-fidPRrvW  ] file ...
    # netbsd:    rm [-fidPRrvWx ] file ...
    # freebsd:   rm [-fidPRrvWxI] file ...
    # dragonfly: rm [-fidPRrvWxI] file ... 

    complete -c rm -s f -d "Never prompt for removal"
    complete -c rm -s i -d "Prompt for removal"
    test "$uname" = SunOS
    and exit 0
    complete -c rm -s d -d "Remove directories as well"
    complete -c rm -s P -d "Overwrite before removal"
    complete -c rm -s R -s r -d "Recursively remove subdirs"
    complete -c rm -s v -d "Explain what is done"
    test "$uname" = OpenBSD
    and exit 0
    complete -c rm -s W -d "Undelete given filenames"
    test "$uname" = Darwin
    and exit 0
    complete -c rm -s x -d "Don't traverse mount points"
    test "$uname" = NetBSD
    and exit 0
    complete -c rm -s I -d "Prompt to remove >=3 files"
...
3402	3402	--> rm --version >/dev/null 2>/dev/null
293	293	--> complete -c rm -s d -l directory -d "Unlink directories"
70	70	--> complete -c rm -s f -l force -d "Never prompt for removal"
58	58	--> complete -c rm -s i -l interactive -d "Prompt for removal"
52	52	--> complete -c rm -s I -d "Prompt to remove >3 files"
54	54	--> complete -c rm -s r -l recursive -d "Recursively remove subdirs"
51	51	--> complete -c rm -s R -d "Recursively remove subdirs"
55	55	--> complete -c rm -s v -l verbose -d "Explain what is done"
55	55	--> complete -c rm -s h -l help -d "Display help"
70	70	--> complete -c rm -l version -d "Display rm version"
129	393	> __fish_disable_bracketed_paste 'rm -rf .idea/'
264	264	-> printf "\e[?2004l"
91	1515	> fish_title rm\ -rf\ .idea/
29	1424	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
876	1345	--> echo (status current-command) (__fish_pwd)
57	57	---> status current-command
251	412	---> __fish_pwd
161	161	----> pwd
35092	35092	> rm -rf .idea/
106	223	> __fish_enable_bracketed_paste
117	117	-> printf "\e[?2004h"
112	528	> fish_mode_prompt
242	416	-> fish_default_mode_prompt
28	174	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
95	95	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
51	51	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
218	179791	> fish_prompt
106	106	-> set -l __last_command_exit_status $status
7	44	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
37	37	--> not set -q -g __fish_robbyrussell_functions_defined
470	682	-> set -l cyan (set_color -o cyan)
212	212	--> set_color -o cyan
406	510	-> set -l yellow (set_color -o yellow)
104	104	--> set_color -o yellow
387	499	-> set -l red (set_color -o red)
112	112	--> set_color -o red
418	510	-> set -l green (set_color -o green)
92	92	--> set_color -o green
410	501	-> set -l blue (set_color -o blue)
91	91	--> set_color -o blue
424	509	-> set -l normal (set_color normal)
85	85	--> set_color normal
73	73	-> set -l arrow_color "$green"
9	61	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
52	52	--> test $__last_command_exit_status != 0
53	53	-> set -l arrow "$arrow_color➜ "
7	88	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
81	81	--> test "$USER" = 'root'
417	4518	-> set -l cwd $cyan(basename (prompt_pwd))
2748	4101	--> basename (prompt_pwd)
273	1353	---> prompt_pwd
68	68	----> set -l options 'h/help'
94	94	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	35	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
56	56	----> set realhome ~
334	574	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
240	240	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
20	193	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
62	62	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
111	111	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
38	171385	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
480	8181	--> set -l repo_type (_repo_type)
73	7701	---> _repo_type
32	7628	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
54	467	-----> _is_hg_repo
240	413	------> fish_print_hg_root >/dev/null
27	173	-------> if not command -sq hg
        return 1
    ...
117	117	--------> not command -sq hg
29	29	--------> return 1
77	7009	-----> _is_git_repo
286	3052	------> type -q git
38	38	-------> set -q argv[1]
76	76	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
153	153	-------> argparse -n type -x t,p,P $options -- $argv
6	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
32	32	-------> set -l res 1
31	31	-------> set -l mode normal
28	28	-------> set -l multi no
30	30	-------> set -l selection all
27	27	-------> set -l short no
17	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
29	29	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
81	2140	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
56	1165	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
5	247	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
242	242	----------> functions -q -- $i
12	821	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
679	809	----------> contains -- $i (builtin -n)
130	130	-----------> builtin -n
48	48	--------> set -l paths
25	535	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
43	43	---------> test $multi != yes
344	467	---------> set paths (command -s -- $i)
123	123	----------> command -s -- $i
63	241	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
46	46	---------> set res 0
32	32	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	77	---------> if test $multi != yes
                continue
            ...
40	40	----------> test $multi != yes
22	22	----------> continue
7	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
39	39	-------> return $res
3880	3880	------> git rev-parse --git-dir >/dev/null 2>&1
91	91	-----> echo 'git'
29	29	-----> return 0
422	6091	--> set -l repo_branch $red(_repo_branch_name $repo_type)
93	5669	---> _repo_branch_name $repo_type
97	5576	----> _$argv[1]_branch_name
465	4888	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4423	4423	------> git symbolic-ref --quiet HEAD 2>/dev/null
31	591	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
63	63	------> set -q branch[1]
350	497	------> echo (string replace -r '^refs/heads/' '' $branch)
147	147	-------> string replace -r '^refs/heads/' '' $branch
81	81	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
12	156994	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
290	156937	---> [ (_is_repo_dirty $repo_type) ]
76	156647	----> _is_repo_dirty $repo_type
59	156571	-----> _is_$argv[1]_dirty
444	156512	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
156068	156068	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
34	34	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
23	309	> fish_title
10	286	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
13	13	--> not set -q INSIDE_EMACS
205	263	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
26	42	---> __fish_pwd
16	16	----> pwd
145	290	> __fish_disable_bracketed_paste clear
145	145	-> printf "\e[?2004l"
93	1099	> fish_title clear
35	1006	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
708	921	--> echo (status current-command) (__fish_pwd)
64	64	---> status current-command
91	149	---> __fish_pwd
58	58	----> pwd
3577	3577	> clear
114	274	> __fish_enable_bracketed_paste
160	160	-> printf "\e[?2004h"
109	391	> fish_mode_prompt
105	282	-> fish_default_mode_prompt
22	177	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
108	108	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
47	47	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
233	194799	> fish_prompt
114	114	-> set -l __last_command_exit_status $status
7	46	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
39	39	--> not set -q -g __fish_robbyrussell_functions_defined
472	574	-> set -l cyan (set_color -o cyan)
102	102	--> set_color -o cyan
461	572	-> set -l yellow (set_color -o yellow)
111	111	--> set_color -o yellow
398	492	-> set -l red (set_color -o red)
94	94	--> set_color -o red
386	478	-> set -l green (set_color -o green)
92	92	--> set_color -o green
376	475	-> set -l blue (set_color -o blue)
99	99	--> set_color -o blue
440	545	-> set -l normal (set_color normal)
105	105	--> set_color normal
88	88	-> set -l arrow_color "$green"
11	77	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
66	66	--> test $__last_command_exit_status != 0
74	74	-> set -l arrow "$arrow_color➜ "
12	86	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
74	74	--> test "$USER" = 'root'
505	7625	-> set -l cwd $cyan(basename (prompt_pwd))
5568	7120	--> basename (prompt_pwd)
218	1552	---> prompt_pwd
74	74	----> set -l options 'h/help'
109	109	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
11	57	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
46	46	-----> set -q _flag_help
83	83	----> set -q fish_prompt_pwd_dir_length
53	53	----> set -l fish_prompt_pwd_dir_length 1
88	88	----> set realhome ~
396	544	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
148	148	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
39	326	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
93	93	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
194	194	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
37	183285	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
471	7819	--> set -l repo_type (_repo_type)
98	7348	---> _repo_type
49	7250	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
50	328	-----> _is_hg_repo
106	278	------> fish_print_hg_root >/dev/null
21	172	-------> if not command -sq hg
        return 1
    ...
122	122	--------> not command -sq hg
29	29	--------> return 1
120	6681	-----> _is_git_repo
179	2668	------> type -q git
37	37	-------> set -q argv[1]
81	81	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
151	151	-------> argparse -n type -x t,p,P $options -- $argv
6	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
33	33	-------> set -l res 1
32	32	-------> set -l mode normal
28	28	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
17	69	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
29	29	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
20	20	-------> set -q _flag_no_functions
66	1864	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
33	33	--------> set -l found 0
38	904	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
40	40	---------> test $selection != files
7	75	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
68	68	----------> functions -q -- $i
18	751	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
604	733	----------> contains -- $i (builtin -n)
129	129	-----------> builtin -n
61	61	--------> set -l paths
27	533	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
49	49	---------> test $multi != yes
319	457	---------> set paths (command -s -- $i)
138	138	----------> command -s -- $i
57	229	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
43	43	---------> set res 0
32	32	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	74	---------> if test $multi != yes
                continue
            ...
37	37	----------> test $multi != yes
22	22	----------> continue
7	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
36	36	-------> return $res
3893	3893	------> git rev-parse --git-dir >/dev/null 2>&1
146	146	-----> echo 'git'
46	46	-----> return 0
395	6078	--> set -l repo_branch $red(_repo_branch_name $repo_type)
90	5683	---> _repo_branch_name $repo_type
99	5593	----> _$argv[1]_branch_name
447	4925	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4478	4478	------> git symbolic-ref --quiet HEAD 2>/dev/null
30	569	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
47	47	------> set -q branch[1]
366	492	------> echo (string replace -r '^refs/heads/' '' $branch)
126	126	-------> string replace -r '^refs/heads/' '' $branch
80	80	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
16	169271	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
289	169207	---> [ (_is_repo_dirty $repo_type) ]
75	168918	----> _is_repo_dirty $repo_type
62	168843	-----> _is_$argv[1]_dirty
510	168781	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
168271	168271	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
33	252	> fish_title
7	219	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
143	198	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
25	40	---> __fish_pwd
15	15	----> pwd
128	219	> __fish_disable_bracketed_paste 'ls -alF'
91	91	-> printf "\e[?2004l"
102	1179	> fish_title ls\ -alF
33	1077	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
52	52	--> not set -q INSIDE_EMACS
763	992	--> echo (status current-command) (__fish_pwd)
56	56	---> status current-command
110	173	---> __fish_pwd
63	63	----> pwd
458	10102	> ls -alF
440	3586	-> isatty stdout
68	68	--> set -l options 'h/help'
86	86	--> argparse -n isatty $options -- $argv
15	49	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
34	34	---> set -q _flag_help
11	45	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
34	34	---> set -q argv[2]
38	38	--> set -l fd
47	84	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
37	37	---> set fd 1
2776	2776	--> command [ -t "$fd" ]
101	101	-> set -a opt -F
5957	5957	-> command ls $opt $argv
137	311	> __fish_enable_bracketed_paste
174	174	-> printf "\e[?2004h"
110	538	> fish_mode_prompt
163	428	-> fish_default_mode_prompt
32	265	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
126	126	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
107	107	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
247	166389	> fish_prompt
139	139	-> set -l __last_command_exit_status $status
12	62	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
50	50	--> not set -q -g __fish_robbyrussell_functions_defined
483	625	-> set -l cyan (set_color -o cyan)
142	142	--> set_color -o cyan
2839	2944	-> set -l yellow (set_color -o yellow)
105	105	--> set_color -o yellow
452	558	-> set -l red (set_color -o red)
106	106	--> set_color -o red
450	543	-> set -l green (set_color -o green)
93	93	--> set_color -o green
421	501	-> set -l blue (set_color -o blue)
80	80	--> set_color -o blue
445	516	-> set -l normal (set_color normal)
71	71	--> set_color normal
64	64	-> set -l arrow_color "$green"
7	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
47	47	-> set -l arrow "$arrow_color➜ "
6	69	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
63	63	--> test "$USER" = 'root'
459	4147	-> set -l cwd $cyan(basename (prompt_pwd))
2475	3688	--> basename (prompt_pwd)
145	1213	---> prompt_pwd
56	56	----> set -l options 'h/help'
76	76	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
31	31	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
57	57	----> set realhome ~
418	562	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
144	144	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
26	221	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
69	69	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
126	126	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	155840	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
449	8747	--> set -l repo_type (_repo_type)
100	8298	---> _repo_type
46	8198	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
54	339	-----> _is_hg_repo
106	285	------> fish_print_hg_root >/dev/null
27	179	-------> if not command -sq hg
        return 1
    ...
124	124	--------> not command -sq hg
28	28	--------> return 1
95	7626	-----> _is_git_repo
219	3014	------> type -q git
46	46	-------> set -q argv[1]
80	80	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
152	152	-------> argparse -n type -x t,p,P $options -- $argv
5	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
32	32	--------> set -q _flag_help
34	34	-------> set -l res 1
34	34	-------> set -l mode normal
63	63	-------> set -l multi no
36	36	-------> set -l selection all
27	27	-------> set -l short no
18	70	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
29	29	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
92	2100	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
34	34	--------> set -l found 0
38	930	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
48	48	---------> test $selection != files
6	63	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
57	57	----------> functions -q -- $i
19	781	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
625	762	----------> contains -- $i (builtin -n)
137	137	-----------> builtin -n
58	58	--------> set -l paths
27	551	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
340	476	---------> set paths (command -s -- $i)
136	136	----------> command -s -- $i
84	365	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
67	67	---------> set res 0
55	55	---------> set found 1
39	39	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
28	120	---------> if test $multi != yes
                continue
            ...
58	58	----------> test $multi != yes
34	34	----------> continue
14	70	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
56	56	---------> test $found = 0
49	49	-------> return $res
4517	4517	------> git rev-parse --git-dir >/dev/null 2>&1
129	129	-----> echo 'git'
58	58	-----> return 0
410	6156	--> set -l repo_branch $red(_repo_branch_name $repo_type)
123	5746	---> _repo_branch_name $repo_type
157	5623	----> _$argv[1]_branch_name
528	4679	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4151	4151	------> git symbolic-ref --quiet HEAD 2>/dev/null
38	787	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
59	59	------> set -q branch[1]
519	690	------> echo (string replace -r '^refs/heads/' '' $branch)
171	171	-------> string replace -r '^refs/heads/' '' $branch
105	105	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
17	140796	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
316	140732	---> [ (_is_repo_dirty $repo_type) ]
325	140416	----> _is_repo_dirty $repo_type
87	140091	-----> _is_$argv[1]_dirty
505	140004	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
139499	139499	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
34	34	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
23	352	> fish_title
9	329	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
249	306	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
25	41	---> __fish_pwd
16	16	----> pwd
123	218	> __fish_disable_bracketed_paste 'cd ..'
95	95	-> printf "\e[?2004l"
90	1079	> fish_title cd\ ..
35	989	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
702	906	--> echo (status current-command) (__fish_pwd)
64	64	---> status current-command
85	140	---> __fish_pwd
55	55	----> pwd
535	4152	> cd ..
900	984	-> source /usr/share/fish/functions/cd.fish
84	84	--> function cd --description "Change directory"
    set -l MAX_DIR_HIST 25

    if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    end

    # Skip history in subshells.
    if status --is-command-substitution
        builtin cd $argv
        return $status
    end

    # Avoid set completions.
    set -l previous $PWD

    if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    end

    # allow explicit "cd ." if the mount-point became stale in the meantime
    if test "$argv" = "."
        cd "$PWD"
        return $status
    end

    builtin cd $argv
    set -l cd_status $status

    if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    end

    return $cd_status
...
66	66	-> set -l MAX_DIR_HIST 25
16	941	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
539	925	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
265	265	---> count $argv
74	74	---> test "$argv[1]" = "--"
47	47	---> echo 1
12	49	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
37	37	--> status --is-command-substitution
64	64	-> set -l previous $PWD
12	59	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
47	47	--> test "$argv" = "-"
12	48	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
36	36	--> test "$argv" = "."
158	816	-> builtin cd $argv
88	658	--> __update_cwd_osc VARIABLE SET PWD
11	79	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
34	34	----> status --is-command-substitution
34	34	----> set -q INSIDE_EMACS
411	491	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
80	80	----> string escape --style=url $PWD
74	74	-> set -l cd_status $status
77	480	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
82	82	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
34	34	--> set -q dirprev
37	37	--> set -l dirprev
61	61	--> set -q dirprev[$MAX_DIR_HIST]
25	25	--> set -U -q dirprev
50	50	--> set -g -a dirprev $previous
24	24	--> set -U -q dirnext
26	26	--> set -e dirnext
24	24	--> set -U -q __fish_cd_direction
40	40	--> set -g __fish_cd_direction prev
36	36	-> return $cd_status
54	119	> __fish_enable_bracketed_paste
65	65	-> printf "\e[?2004h"
51	207	> fish_mode_prompt
50	156	-> fish_default_mode_prompt
14	106	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
55	55	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
203	15968	> fish_prompt
75	75	-> set -l __last_command_exit_status $status
5	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
360	435	-> set -l cyan (set_color -o cyan)
75	75	--> set_color -o cyan
279	346	-> set -l yellow (set_color -o yellow)
67	67	--> set_color -o yellow
338	396	-> set -l red (set_color -o red)
58	58	--> set_color -o red
343	433	-> set -l green (set_color -o green)
90	90	--> set_color -o green
274	341	-> set -l blue (set_color -o blue)
67	67	--> set_color -o blue
338	392	-> set -l normal (set_color normal)
54	54	--> set_color normal
63	63	-> set -l arrow_color "$green"
8	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
47	47	-> set -l arrow "$arrow_color➜ "
5	46	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
41	41	--> test "$USER" = 'root'
440	4907	-> set -l cwd $cyan(basename (prompt_pwd))
3409	4467	--> basename (prompt_pwd)
126	1058	---> prompt_pwd
50	50	----> set -l options 'h/help'
67	67	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
49	49	----> set realhome ~
331	491	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
160	160	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
20	180	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
54	54	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
106	106	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
15	8069	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
365	8054	--> set -l repo_type (_repo_type)
86	7689	---> _repo_type
14	7542	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
44	382	-----> _is_hg_repo
112	338	------> fish_print_hg_root >/dev/null
25	226	-------> if not command -sq hg
        return 1
    ...
166	166	--------> not command -sq hg
35	35	--------> return 1
79	7146	-----> _is_git_repo
190	3570	------> type -q git
38	38	-------> set -q argv[1]
77	77	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
140	140	-------> argparse -n type -x t,p,P $options -- $argv
6	36	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
30	30	--------> set -q _flag_help
34	34	-------> set -l res 1
33	33	-------> set -l mode normal
28	28	-------> set -l multi no
30	30	-------> set -l selection all
27	27	-------> set -l short no
16	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
30	30	--------> set mode quiet
63	63	-------> set -q _flag_all
23	23	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
69	2724	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
33	33	--------> set -l found 0
56	930	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
7	63	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
17	770	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
632	753	----------> contains -- $i (builtin -n)
121	121	-----------> builtin -n
59	59	--------> set -l paths
29	1343	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
49	49	---------> test $multi != yes
1131	1265	---------> set paths (command -s -- $i)
134	134	----------> command -s -- $i
67	250	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
48	48	---------> set res 0
33	33	---------> set found 1
24	24	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	78	---------> if test $multi != yes
                continue
            ...
40	40	----------> test $multi != yes
23	23	----------> continue
6	40	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
34	34	---------> test $found = 0
38	38	-------> return $res
3497	3497	------> git rev-parse --git-dir >/dev/null 2>&1
61	61	----> return 1
127	127	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
106	1022	> fish_title
26	916	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
44	44	--> not set -q INSIDE_EMACS
650	846	--> echo (status current-command) (__fish_pwd)
47	47	---> status current-command
95	149	---> __fish_pwd
54	54	----> pwd
18528	18835	> source /usr/share/fish/completions/cd.fish
220	220	-> complete -c cd -a "(__fish_complete_cd)"
87	87	-> complete -c cd -s h -l help -d 'Display help and exit'
115	328	> __fish_disable_bracketed_paste 'cd Documents/FitMe/'
213	213	-> printf "\e[?2004l"
102	1528	> fish_title cd\ Documents/FitMe/
33	1426	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
881	1343	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
246	407	---> __fish_pwd
161	161	----> pwd
206	3107	> cd Documents/FitMe/
62	62	-> set -l MAX_DIR_HIST 25
25	798	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
570	773	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
82	82	---> count $argv
74	74	---> test "$argv[1]" = "--"
47	47	---> echo 1
15	58	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
43	43	--> status --is-command-substitution
71	71	-> set -l previous $PWD
12	64	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
52	52	--> test "$argv" = "-"
15	114	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
99	99	--> test "$argv" = "."
183	1139	-> builtin cd $argv
90	956	--> __update_cwd_osc VARIABLE SET PWD
11	78	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
33	33	----> status --is-command-substitution
34	34	----> set -q INSIDE_EMACS
581	788	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
207	207	----> string escape --style=url $PWD
92	92	-> set -l cd_status $status
77	459	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
95	95	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
36	36	--> set -q dirprev
45	45	--> set -q dirprev[$MAX_DIR_HIST]
30	30	--> set -U -q dirprev
53	53	--> set -g -a dirprev $previous
26	26	--> set -U -q dirnext
29	29	--> set -e dirnext
27	27	--> set -U -q __fish_cd_direction
41	41	--> set -g __fish_cd_direction prev
44	44	-> return $cd_status
59	134	> __fish_enable_bracketed_paste
75	75	-> printf "\e[?2004h"
63	392	> fish_mode_prompt
198	329	-> fish_default_mode_prompt
20	131	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
67	67	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
44	44	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
231	12211723	> fish_prompt
92	92	-> set -l __last_command_exit_status $status
8	48	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
40	40	--> not set -q -g __fish_robbyrussell_functions_defined
408	593	-> set -l cyan (set_color -o cyan)
185	185	--> set_color -o cyan
290	358	-> set -l yellow (set_color -o yellow)
68	68	--> set_color -o yellow
352	412	-> set -l red (set_color -o red)
60	60	--> set_color -o red
432	510	-> set -l green (set_color -o green)
78	78	--> set_color -o green
416	495	-> set -l blue (set_color -o blue)
79	79	--> set_color -o blue
397	467	-> set -l normal (set_color normal)
70	70	--> set_color normal
54	54	-> set -l arrow_color "$green"
7	50	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
43	43	--> test $__last_command_exit_status != 0
61	61	-> set -l arrow "$arrow_color➜ "
10	72	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
62	62	--> test "$USER" = 'root'
511	5978	-> set -l cwd $cyan(basename (prompt_pwd))
4017	5467	--> basename (prompt_pwd)
339	1450	---> prompt_pwd
83	83	----> set -l options 'h/help'
81	81	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
9	53	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
44	44	-----> set -q _flag_help
38	38	----> set -q fish_prompt_pwd_dir_length
52	52	----> set -l fish_prompt_pwd_dir_length 1
73	73	----> set realhome ~
391	541	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
150	150	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
22	190	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
60	60	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
108	108	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
45	12202260	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
500	144597	--> set -l repo_type (_repo_type)
82	144097	---> _repo_type
35	144015	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
101	499	-----> _is_hg_repo
224	398	------> fish_print_hg_root >/dev/null
22	174	-------> if not command -sq hg
        return 1
    ...
122	122	--------> not command -sq hg
30	30	--------> return 1
97	143332	-----> _is_git_repo
282	3045	------> type -q git
39	39	-------> set -q argv[1]
76	76	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
140	140	-------> argparse -n type -x t,p,P $options -- $argv
7	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
32	32	-------> set -l res 1
31	31	-------> set -l mode normal
28	28	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
18	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
28	28	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
76	2151	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
56	56	--------> set -l found 0
26	1148	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
40	40	---------> test $selection != files
5	248	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
243	243	----------> functions -q -- $i
16	834	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
695	818	----------> contains -- $i (builtin -n)
123	123	-----------> builtin -n
57	57	--------> set -l paths
45	535	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
313	442	---------> set paths (command -s -- $i)
129	129	----------> command -s -- $i
69	241	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
46	46	---------> set res 0
31	31	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
13	72	---------> if test $multi != yes
                continue
            ...
37	37	----------> test $multi != yes
22	22	----------> continue
7	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
37	37	-------> return $res
140190	140190	------> git rev-parse --git-dir >/dev/null 2>&1
115	115	-----> echo 'git'
34	34	-----> return 0
528	46083	--> set -l repo_branch $red(_repo_branch_name $repo_type)
108	45555	---> _repo_branch_name $repo_type
107	45447	----> _$argv[1]_branch_name
527	44620	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
44093	44093	------> git symbolic-ref --quiet HEAD 2>/dev/null
35	720	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
54	54	------> set -q branch[1]
495	631	------> echo (string replace -r '^refs/heads/' '' $branch)
136	136	-------> string replace -r '^refs/heads/' '' $branch
94	94	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
14	12011441	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
418	12011370	---> [ (_is_repo_dirty $repo_type) ]
102	12010952	----> _is_repo_dirty $repo_type
84	12010850	-----> _is_$argv[1]_dirty
845	12010766	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
12009921	12009921	-------> git status -s --ignore-submodules=dirty 2>/dev/null
34	34	---> set -l dirty "$yellow ✗"
23	23	---> set repo_info "$repo_info$dirty"
42	42	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
29	369	> fish_title
11	340	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
16	16	--> not set -q INSIDE_EMACS
245	313	--> echo (status current-command) (__fish_pwd)
20	20	---> status current-command
28	48	---> __fish_pwd
20	20	----> pwd
157	497	> __fish_disable_bracketed_paste clear
340	340	-> printf "\e[?2004l"
116	1773	> fish_title clear
44	1657	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
69	69	--> not set -q INSIDE_EMACS
1034	1544	--> echo (status current-command) (__fish_pwd)
82	82	---> status current-command
262	428	---> __fish_pwd
166	166	----> pwd
3664	3664	> clear
108	240	> __fish_enable_bracketed_paste
132	132	-> printf "\e[?2004h"
97	509	> fish_mode_prompt
227	412	-> fish_default_mode_prompt
26	185	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
109	109	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
50	50	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
265	216851	> fish_prompt
108	108	-> set -l __last_command_exit_status $status
8	47	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
39	39	--> not set -q -g __fish_robbyrussell_functions_defined
453	687	-> set -l cyan (set_color -o cyan)
234	234	--> set_color -o cyan
381	474	-> set -l yellow (set_color -o yellow)
93	93	--> set_color -o yellow
336	408	-> set -l red (set_color -o red)
72	72	--> set_color -o red
394	495	-> set -l green (set_color -o green)
101	101	--> set_color -o green
480	622	-> set -l blue (set_color -o blue)
142	142	--> set_color -o blue
847	1035	-> set -l normal (set_color normal)
188	188	--> set_color normal
112	112	-> set -l arrow_color "$green"
15	103	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
88	88	--> test $__last_command_exit_status != 0
80	80	-> set -l arrow "$arrow_color➜ "
7	71	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
64	64	--> test "$USER" = 'root'
465	5322	-> set -l cwd $cyan(basename (prompt_pwd))
2919	4857	--> basename (prompt_pwd)
304	1938	---> prompt_pwd
72	72	----> set -l options 'h/help'
92	92	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	42	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
35	35	-----> set -q _flag_help
30	30	----> set -q fish_prompt_pwd_dir_length
40	40	----> set -l fish_prompt_pwd_dir_length 1
68	68	----> set realhome ~
708	1053	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
345	345	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
24	237	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
75	75	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
138	138	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
32	206987	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
455	9548	--> set -l repo_type (_repo_type)
101	9093	---> _repo_type
30	8992	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
59	505	-----> _is_hg_repo
250	446	------> fish_print_hg_root >/dev/null
25	196	-------> if not command -sq hg
        return 1
    ...
137	137	--------> not command -sq hg
34	34	--------> return 1
89	8327	-----> _is_git_repo
359	3409	------> type -q git
45	45	-------> set -q argv[1]
87	87	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
180	180	-------> argparse -n type -x t,p,P $options -- $argv
7	43	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
36	36	--------> set -q _flag_help
37	37	-------> set -l res 1
36	36	-------> set -l mode normal
33	33	-------> set -l multi no
33	33	-------> set -l selection all
31	31	-------> set -l short no
22	82	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
34	34	--------> set mode quiet
27	27	-------> set -q _flag_all
25	25	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
83	2322	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
37	37	--------> set -l found 0
46	1313	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
46	46	---------> test $selection != files
7	297	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
290	290	----------> functions -q -- $i
15	924	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
784	909	----------> contains -- $i (builtin -n)
125	125	-----------> builtin -n
59	59	--------> set -l paths
22	572	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
348	502	---------> set paths (command -s -- $i)
154	154	----------> command -s -- $i
53	219	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
41	41	---------> set res 0
31	31	---------> set found 1
22	22	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	72	---------> if test $multi != yes
                continue
            ...
35	35	----------> test $multi != yes
22	22	----------> continue
7	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
45	45	-------> return $res
4829	4829	------> git rev-parse --git-dir >/dev/null 2>&1
100	100	-----> echo 'git'
30	30	-----> return 0
363	6579	--> set -l repo_branch $red(_repo_branch_name $repo_type)
94	6216	---> _repo_branch_name $repo_type
96	6122	----> _$argv[1]_branch_name
420	5417	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4997	4997	------> git symbolic-ref --quiet HEAD 2>/dev/null
32	609	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
50	50	------> set -q branch[1]
396	527	------> echo (string replace -r '^refs/heads/' '' $branch)
131	131	-------> string replace -r '^refs/heads/' '' $branch
137	137	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
14	190691	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
362	190630	---> [ (_is_repo_dirty $repo_type) ]
75	190268	----> _is_repo_dirty $repo_type
58	190193	-----> _is_$argv[1]_dirty
594	190135	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
189541	189541	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
21	269	> fish_title
7	248	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
158	227	--> echo (status current-command) (__fish_pwd)
27	27	---> status current-command
27	42	---> __fish_pwd
15	15	----> pwd
124	216	> __fish_disable_bracketed_paste 'ls -alF'
92	92	-> printf "\e[?2004l"
99	1111	> fish_title ls\ -alF
31	1012	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
51	51	--> not set -q INSIDE_EMACS
703	930	--> echo (status current-command) (__fish_pwd)
54	54	---> status current-command
110	173	---> __fish_pwd
63	63	----> pwd
459	10041	> ls -alF
421	3589	-> isatty stdout
74	74	--> set -l options 'h/help'
79	79	--> argparse -n isatty $options -- $argv
15	48	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
33	33	---> set -q _flag_help
11	47	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
36	36	---> set -q argv[2]
39	39	--> set -l fd
48	86	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
38	38	---> set fd 1
2795	2795	--> command [ -t "$fd" ]
94	94	-> set -a opt -F
5899	5899	-> command ls $opt $argv
105	243	> __fish_enable_bracketed_paste
138	138	-> printf "\e[?2004h"
102	386	> fish_mode_prompt
108	284	-> fish_default_mode_prompt
25	176	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
93	93	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
58	58	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
229	201678	> fish_prompt
106	106	-> set -l __last_command_exit_status $status
7	41	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
528	638	-> set -l cyan (set_color -o cyan)
110	110	--> set_color -o cyan
371	466	-> set -l yellow (set_color -o yellow)
95	95	--> set_color -o yellow
380	447	-> set -l red (set_color -o red)
67	67	--> set_color -o red
346	450	-> set -l green (set_color -o green)
104	104	--> set_color -o green
402	482	-> set -l blue (set_color -o blue)
80	80	--> set_color -o blue
378	453	-> set -l normal (set_color normal)
75	75	--> set_color normal
66	66	-> set -l arrow_color "$green"
8	54	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
5	69	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
64	64	--> test "$USER" = 'root'
429	4005	-> set -l cwd $cyan(basename (prompt_pwd))
2357	3576	--> basename (prompt_pwd)
160	1219	---> prompt_pwd
66	66	----> set -l options 'h/help'
83	83	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
61	61	----> set realhome ~
372	516	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
144	144	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
28	238	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
82	82	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
128	128	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
39	194091	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
540	10968	--> set -l repo_type (_repo_type)
93	10428	---> _repo_type
31	10335	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
52	341	-----> _is_hg_repo
108	289	------> fish_print_hg_root >/dev/null
26	181	-------> if not command -sq hg
        return 1
    ...
126	126	--------> not command -sq hg
29	29	--------> return 1
89	9834	-----> _is_git_repo
212	3270	------> type -q git
38	38	-------> set -q argv[1]
81	81	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
160	160	-------> argparse -n type -x t,p,P $options -- $argv
6	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
32	32	--------> set -q _flag_help
33	33	-------> set -l res 1
31	31	-------> set -l mode normal
27	27	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
18	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
28	28	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
92	2402	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
43	43	--------> set -l found 0
41	932	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
6	64	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
17	786	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
630	769	----------> contains -- $i (builtin -n)
139	139	-----------> builtin -n
60	60	--------> set -l paths
34	817	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
47	47	---------> test $multi != yes
555	736	---------> set paths (command -s -- $i)
181	181	----------> command -s -- $i
95	399	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
73	73	---------> set res 0
69	69	---------> set found 1
42	42	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
27	120	---------> if test $multi != yes
                continue
            ...
61	61	----------> test $multi != yes
32	32	----------> continue
12	59	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
47	47	---------> test $found = 0
57	57	-------> return $res
6475	6475	------> git rev-parse --git-dir >/dev/null 2>&1
100	100	-----> echo 'git'
29	29	-----> return 0
516	5556	--> set -l repo_branch $red(_repo_branch_name $repo_type)
91	5040	---> _repo_branch_name $repo_type
92	4949	----> _$argv[1]_branch_name
449	4323	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3874	3874	------> git symbolic-ref --quiet HEAD 2>/dev/null
26	534	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
44	44	------> set -q branch[1]
342	464	------> echo (string replace -r '^refs/heads/' '' $branch)
122	122	-------> string replace -r '^refs/heads/' '' $branch
80	80	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
16	177448	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
389	177386	---> [ (_is_repo_dirty $repo_type) ]
84	176997	----> _is_repo_dirty $repo_type
60	176913	-----> _is_$argv[1]_dirty
693	176853	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
176160	176160	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
25	311	> fish_title
9	286	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
17	17	--> not set -q INSIDE_EMACS
202	260	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
26	42	---> __fish_pwd
16	16	----> pwd
121	215	> __fish_disable_bracketed_paste 'rm -rf .idea/'
94	94	-> printf "\e[?2004l"
101	1284	> fish_title rm\ -rf\ .idea/
36	1183	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
49	49	--> not set -q INSIDE_EMACS
850	1098	--> echo (status current-command) (__fish_pwd)
76	76	---> status current-command
109	172	---> __fish_pwd
63	63	----> pwd
127857	127857	> rm -rf .idea/
105	240	> __fish_enable_bracketed_paste
135	135	-> printf "\e[?2004h"
82	362	> fish_mode_prompt
110	280	-> fish_default_mode_prompt
24	170	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
101	101	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
45	45	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
249	238798	> fish_prompt
121	121	-> set -l __last_command_exit_status $status
9	48	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
39	39	--> not set -q -g __fish_robbyrussell_functions_defined
474	591	-> set -l cyan (set_color -o cyan)
117	117	--> set_color -o cyan
416	507	-> set -l yellow (set_color -o yellow)
91	91	--> set_color -o yellow
516	613	-> set -l red (set_color -o red)
97	97	--> set_color -o red
415	531	-> set -l green (set_color -o green)
116	116	--> set_color -o green
459	582	-> set -l blue (set_color -o blue)
123	123	--> set_color -o blue
430	528	-> set -l normal (set_color normal)
98	98	--> set_color normal
84	84	-> set -l arrow_color "$green"
9	64	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
55	55	--> test $__last_command_exit_status != 0
53	53	-> set -l arrow "$arrow_color➜ "
7	63	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
56	56	--> test "$USER" = 'root'
481	4795	-> set -l cwd $cyan(basename (prompt_pwd))
2826	4314	--> basename (prompt_pwd)
209	1488	---> prompt_pwd
80	80	----> set -l options 'h/help'
91	91	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	41	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
34	34	-----> set -q _flag_help
69	69	----> set -q fish_prompt_pwd_dir_length
68	68	----> set -l fish_prompt_pwd_dir_length 1
84	84	----> set realhome ~
421	598	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
177	177	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
30	248	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
75	75	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
143	143	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
41	229934	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
348	7752	--> set -l repo_type (_repo_type)
100	7404	---> _repo_type
31	7304	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
51	350	-----> _is_hg_repo
120	299	------> fish_print_hg_root >/dev/null
21	179	-------> if not command -sq hg
        return 1
    ...
129	129	--------> not command -sq hg
29	29	--------> return 1
78	6795	-----> _is_git_repo
185	2971	------> type -q git
48	48	-------> set -q argv[1]
81	81	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
166	166	-------> argparse -n type -x t,p,P $options -- $argv
6	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
32	32	--------> set -q _flag_help
33	33	-------> set -l res 1
32	32	-------> set -l mode normal
28	28	-------> set -l multi no
30	30	-------> set -l selection all
26	26	-------> set -l short no
19	71	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
30	30	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
85	2130	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
34	34	--------> set -l found 0
37	1009	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
40	40	---------> test $selection != files
6	64	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
18	868	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
720	850	----------> contains -- $i (builtin -n)
130	130	-----------> builtin -n
68	68	--------> set -l paths
29	629	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
418	552	---------> set paths (command -s -- $i)
134	134	----------> command -s -- $i
67	266	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
46	46	---------> set res 0
51	51	---------> set found 1
24	24	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
16	78	---------> if test $multi != yes
                continue
            ...
40	40	----------> test $multi != yes
22	22	----------> continue
7	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
35	35	-------> return $res
3746	3746	------> git rev-parse --git-dir >/dev/null 2>&1
100	100	-----> echo 'git'
28	28	-----> return 0
475	5665	--> set -l repo_branch $red(_repo_branch_name $repo_type)
140	5190	---> _repo_branch_name $repo_type
98	5050	----> _$argv[1]_branch_name
451	4344	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3893	3893	------> git symbolic-ref --quiet HEAD 2>/dev/null
30	608	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
44	44	------> set -q branch[1]
413	534	------> echo (string replace -r '^refs/heads/' '' $branch)
121	121	-------> string replace -r '^refs/heads/' '' $branch
79	79	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
15	216397	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
393	216336	---> [ (_is_repo_dirty $repo_type) ]
75	215943	----> _is_repo_dirty $repo_type
62	215868	-----> _is_$argv[1]_dirty
609	215806	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
215197	215197	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
25	346	> fish_title
10	321	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
16	16	--> not set -q INSIDE_EMACS
227	295	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
35	53	---> __fish_pwd
18	18	----> pwd
126	224	> __fish_disable_bracketed_paste clear
98	98	-> printf "\e[?2004l"
97	1108	> fish_title clear
36	1011	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
49	49	--> not set -q INSIDE_EMACS
714	926	--> echo (status current-command) (__fish_pwd)
66	66	---> status current-command
89	146	---> __fish_pwd
57	57	----> pwd
3579	3579	> clear
104	263	> __fish_enable_bracketed_paste
159	159	-> printf "\e[?2004h"
105	403	> fish_mode_prompt
118	298	-> fish_default_mode_prompt
22	180	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
109	109	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
49	49	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
259	219756	> fish_prompt
108	108	-> set -l __last_command_exit_status $status
8	44	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
36	36	--> not set -q -g __fish_robbyrussell_functions_defined
420	526	-> set -l cyan (set_color -o cyan)
106	106	--> set_color -o cyan
446	535	-> set -l yellow (set_color -o yellow)
89	89	--> set_color -o yellow
444	535	-> set -l red (set_color -o red)
91	91	--> set_color -o red
422	534	-> set -l green (set_color -o green)
112	112	--> set_color -o green
424	524	-> set -l blue (set_color -o blue)
100	100	--> set_color -o blue
455	551	-> set -l normal (set_color normal)
96	96	--> set_color normal
77	77	-> set -l arrow_color "$green"
9	74	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
65	65	--> test $__last_command_exit_status != 0
57	57	-> set -l arrow "$arrow_color➜ "
7	65	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
58	58	--> test "$USER" = 'root'
527	5834	-> set -l cwd $cyan(basename (prompt_pwd))
3065	5307	--> basename (prompt_pwd)
238	2242	---> prompt_pwd
91	91	----> set -l options 'h/help'
108	108	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
11	52	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
41	41	-----> set -q _flag_help
44	44	----> set -q fish_prompt_pwd_dir_length
62	62	----> set -l fish_prompt_pwd_dir_length 1
109	109	----> set realhome ~
1001	1263	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
262	262	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
35	275	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
70	70	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
170	170	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
40	209998	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
522	10007	--> set -l repo_type (_repo_type)
166	9485	---> _repo_type
31	9319	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
96	602	-----> _is_hg_repo
208	506	------> fish_print_hg_root >/dev/null
38	298	-------> if not command -sq hg
        return 1
    ...
217	217	--------> not command -sq hg
43	43	--------> return 1
91	8547	-----> _is_git_repo
207	3881	------> type -q git
45	45	-------> set -q argv[1]
99	99	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
193	193	-------> argparse -n type -x t,p,P $options -- $argv
8	44	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
36	36	--------> set -q _flag_help
38	38	-------> set -l res 1
36	36	-------> set -l mode normal
32	32	-------> set -l multi no
32	32	-------> set -l selection all
31	31	-------> set -l short no
20	78	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
32	32	--------> set mode quiet
27	27	-------> set -q _flag_all
25	25	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
82	2933	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
42	42	--------> set -l found 0
48	1150	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
58	58	---------> test $selection != files
14	107	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
93	93	----------> functions -q -- $i
15	937	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
739	922	----------> contains -- $i (builtin -n)
183	183	-----------> builtin -n
54	54	--------> set -l paths
27	1254	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
43	43	---------> test $multi != yes
1045	1184	---------> set paths (command -s -- $i)
139	139	----------> command -s -- $i
87	311	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
49	49	---------> set res 0
48	48	---------> set found 1
36	36	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
19	91	---------> if test $multi != yes
                continue
            ...
50	50	----------> test $multi != yes
22	22	----------> continue
7	40	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
33	33	---------> test $found = 0
37	37	-------> return $res
4575	4575	------> git rev-parse --git-dir >/dev/null 2>&1
111	111	-----> echo 'git'
28	28	-----> return 0
499	6363	--> set -l repo_branch $red(_repo_branch_name $repo_type)
98	5864	---> _repo_branch_name $repo_type
98	5766	----> _$argv[1]_branch_name
401	5133	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4732	4732	------> git symbolic-ref --quiet HEAD 2>/dev/null
25	535	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
49	49	------> set -q branch[1]
337	461	------> echo (string replace -r '^refs/heads/' '' $branch)
124	124	-------> string replace -r '^refs/heads/' '' $branch
81	81	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	193507	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
431	193446	---> [ (_is_repo_dirty $repo_type) ]
85	193015	----> _is_repo_dirty $repo_type
64	192930	-----> _is_$argv[1]_dirty
628	192866	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
192238	192238	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
38	282	> fish_title
8	244	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
163	222	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
27	43	---> __fish_pwd
16	16	----> pwd
133	229	> __fish_disable_bracketed_paste 'ls -alF'
96	96	-> printf "\e[?2004l"
106	1150	> fish_title ls\ -alF
37	1044	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
53	53	--> not set -q INSIDE_EMACS
746	954	--> echo (status current-command) (__fish_pwd)
63	63	---> status current-command
87	145	---> __fish_pwd
58	58	----> pwd
366	10915	> ls -alF
335	3835	-> isatty stdout
73	73	--> set -l options 'h/help'
82	82	--> argparse -n isatty $options -- $argv
14	49	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
35	35	---> set -q _flag_help
10	43	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
33	33	---> set -q argv[2]
37	37	--> set -l fd
48	85	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
37	37	---> set fd 1
3131	3131	--> command [ -t "$fd" ]
106	106	-> set -a opt -F
6608	6608	-> command ls $opt $argv
153	321	> __fish_enable_bracketed_paste
168	168	-> printf "\e[?2004h"
92	362	> fish_mode_prompt
102	270	-> fish_default_mode_prompt
22	168	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
103	103	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
43	43	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
229	212842	> fish_prompt
112	112	-> set -l __last_command_exit_status $status
8	42	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
491	587	-> set -l cyan (set_color -o cyan)
96	96	--> set_color -o cyan
415	510	-> set -l yellow (set_color -o yellow)
95	95	--> set_color -o yellow
372	478	-> set -l red (set_color -o red)
106	106	--> set_color -o red
400	483	-> set -l green (set_color -o green)
83	83	--> set_color -o green
435	538	-> set -l blue (set_color -o blue)
103	103	--> set_color -o blue
399	488	-> set -l normal (set_color normal)
89	89	--> set_color normal
65	65	-> set -l arrow_color "$green"
7	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
49	49	-> set -l arrow "$arrow_color➜ "
16	130	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
114	114	--> test "$USER" = 'root'
495	4162	-> set -l cwd $cyan(basename (prompt_pwd))
2420	3667	--> basename (prompt_pwd)
156	1247	---> prompt_pwd
74	74	----> set -l options 'h/help'
90	90	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	38	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
31	31	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
61	61	----> set realhome ~
388	548	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
160	160	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
25	220	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
65	65	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
130	130	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
32	204879	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
410	9823	--> set -l repo_type (_repo_type)
91	9413	---> _repo_type
31	9322	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
58	383	-----> _is_hg_repo
141	325	------> fish_print_hg_root >/dev/null
22	184	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
28	28	--------> return 1
98	8780	-----> _is_git_repo
178	2749	------> type -q git
38	38	-------> set -q argv[1]
80	80	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
166	166	-------> argparse -n type -x t,p,P $options -- $argv
5	36	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
33	33	-------> set -l res 1
31	31	-------> set -l mode normal
28	28	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
18	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
28	28	--------> set mode quiet
23	23	-------> set -q _flag_all
26	26	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
72	1930	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
41	41	--------> set -l found 0
36	949	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
40	40	---------> test $selection != files
6	62	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
17	811	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
644	794	----------> contains -- $i (builtin -n)
150	150	-----------> builtin -n
63	63	--------> set -l paths
25	526	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
314	453	---------> set paths (command -s -- $i)
139	139	----------> command -s -- $i
59	240	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
44	44	---------> set res 0
39	39	---------> set found 1
24	24	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	74	---------> if test $multi != yes
                continue
            ...
37	37	----------> test $multi != yes
22	22	----------> continue
8	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
35	35	-------> return $res
5933	5933	------> git rev-parse --git-dir >/dev/null 2>&1
100	100	-----> echo 'git'
28	28	-----> return 0
420	6043	--> set -l repo_branch $red(_repo_branch_name $repo_type)
110	5623	---> _repo_branch_name $repo_type
90	5513	----> _$argv[1]_branch_name
386	4770	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4384	4384	------> git symbolic-ref --quiet HEAD 2>/dev/null
31	653	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
49	49	------> set -q branch[1]
451	573	------> echo (string replace -r '^refs/heads/' '' $branch)
122	122	-------> string replace -r '^refs/heads/' '' $branch
83	83	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
21	188898	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
407	188830	---> [ (_is_repo_dirty $repo_type) ]
84	188423	----> _is_repo_dirty $repo_type
61	188339	-----> _is_$argv[1]_dirty
676	188278	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
187602	187602	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
37	37	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
25	378	> fish_title
9	353	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
17	17	--> not set -q INSIDE_EMACS
260	327	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
33	51	---> __fish_pwd
18	18	----> pwd
142	365	> __fish_disable_bracketed_paste 'code .'
223	223	-> printf "\e[?2004l"
94	1505	> fish_title code\ .
31	1411	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
864	1330	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
246	411	---> __fish_pwd
165	165	----> pwd
1797698	1797698	> code .
142	310	> __fish_enable_bracketed_paste
168	168	-> printf "\e[?2004h"
115	741	> fish_mode_prompt
374	626	-> fish_default_mode_prompt
32	252	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
147	147	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
73	73	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
241	202405	> fish_prompt
150	150	-> set -l __last_command_exit_status $status
11	63	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
52	52	--> not set -q -g __fish_robbyrussell_functions_defined
420	719	-> set -l cyan (set_color -o cyan)
299	299	--> set_color -o cyan
419	519	-> set -l yellow (set_color -o yellow)
100	100	--> set_color -o yellow
409	492	-> set -l red (set_color -o red)
83	83	--> set_color -o red
319	414	-> set -l green (set_color -o green)
95	95	--> set_color -o green
277	380	-> set -l blue (set_color -o blue)
103	103	--> set_color -o blue
292	399	-> set -l normal (set_color normal)
107	107	--> set_color normal
77	77	-> set -l arrow_color "$green"
12	76	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
64	64	--> test $__last_command_exit_status != 0
65	65	-> set -l arrow "$arrow_color➜ "
10	95	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
85	85	--> test "$USER" = 'root'
444	5568	-> set -l cwd $cyan(basename (prompt_pwd))
3214	5124	--> basename (prompt_pwd)
397	1910	---> prompt_pwd
87	87	----> set -l options 'h/help'
117	117	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
24	74	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
50	50	-----> set -q _flag_help
39	39	----> set -q fish_prompt_pwd_dir_length
54	54	----> set -l fish_prompt_pwd_dir_length 1
93	93	----> set realhome ~
420	791	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
371	371	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
29	258	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
75	75	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
154	154	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
41	193112	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
562	10056	--> set -l repo_type (_repo_type)
109	9494	---> _repo_type
45	9385	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
52	492	-----> _is_hg_repo
258	440	------> fish_print_hg_root >/dev/null
26	182	-------> if not command -sq hg
        return 1
    ...
127	127	--------> not command -sq hg
29	29	--------> return 1
98	8661	-----> _is_git_repo
299	3286	------> type -q git
44	44	-------> set -q argv[1]
81	81	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
157	157	-------> argparse -n type -x t,p,P $options -- $argv
7	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
33	33	-------> set -l res 1
32	32	-------> set -l mode normal
28	28	-------> set -l multi no
30	30	-------> set -l selection all
28	28	-------> set -l short no
18	69	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
29	29	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
73	2343	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
38	38	--------> set -l found 0
38	1200	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
8	254	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
246	246	----------> functions -q -- $i
18	867	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
712	849	----------> contains -- $i (builtin -n)
137	137	-----------> builtin -n
63	63	--------> set -l paths
31	673	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
113	113	---------> test $multi != yes
393	529	---------> set paths (command -s -- $i)
136	136	----------> command -s -- $i
65	257	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
47	47	---------> set res 0
42	42	---------> set found 1
25	25	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
16	78	---------> if test $multi != yes
                continue
            ...
41	41	----------> test $multi != yes
21	21	----------> continue
7	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
37	37	-------> return $res
5277	5277	------> git rev-parse --git-dir >/dev/null 2>&1
142	142	-----> echo 'git'
45	45	-----> return 0
446	7188	--> set -l repo_branch $red(_repo_branch_name $repo_type)
139	6742	---> _repo_branch_name $repo_type
136	6603	----> _$argv[1]_branch_name
481	5913	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
5432	5432	------> git symbolic-ref --quiet HEAD 2>/dev/null
26	554	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
46	46	------> set -q branch[1]
358	482	------> echo (string replace -r '^refs/heads/' '' $branch)
124	124	-------> string replace -r '^refs/heads/' '' $branch
81	81	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
15	175746	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
409	175684	---> [ (_is_repo_dirty $repo_type) ]
75	175275	----> _is_repo_dirty $repo_type
75	175200	-----> _is_$argv[1]_dirty
645	175125	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
174480	174480	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
27	381	> fish_title
10	354	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
17	17	--> not set -q INSIDE_EMACS
261	327	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
33	51	---> __fish_pwd
18	18	----> pwd
120	242	> __fish_disable_bracketed_paste clear
122	122	-> printf "\e[?2004l"
99	1139	> fish_title clear
38	1040	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
64	64	--> not set -q INSIDE_EMACS
691	938	--> echo (status current-command) (__fish_pwd)
68	68	---> status current-command
109	179	---> __fish_pwd
70	70	----> pwd
3326	3326	> clear
87	196	> __fish_enable_bracketed_paste
109	109	-> printf "\e[?2004h"
74	333	> fish_mode_prompt
97	259	-> fish_default_mode_prompt
22	162	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
94	94	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
46	46	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
214	324679	> fish_prompt
108	108	-> set -l __last_command_exit_status $status
6	39	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
33	33	--> not set -q -g __fish_robbyrussell_functions_defined
399	500	-> set -l cyan (set_color -o cyan)
101	101	--> set_color -o cyan
352	436	-> set -l yellow (set_color -o yellow)
84	84	--> set_color -o yellow
341	420	-> set -l red (set_color -o red)
79	79	--> set_color -o red
316	391	-> set -l green (set_color -o green)
75	75	--> set_color -o green
327	415	-> set -l blue (set_color -o blue)
88	88	--> set_color -o blue
324	400	-> set -l normal (set_color normal)
76	76	--> set_color normal
65	65	-> set -l arrow_color "$green"
7	52	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
47	47	-> set -l arrow "$arrow_color➜ "
5	75	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
70	70	--> test "$USER" = 'root'
363	4904	-> set -l cwd $cyan(basename (prompt_pwd))
2946	4541	--> basename (prompt_pwd)
199	1595	---> prompt_pwd
84	84	----> set -l options 'h/help'
121	121	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
10	52	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
42	42	-----> set -q _flag_help
38	38	----> set -q fish_prompt_pwd_dir_length
54	54	----> set -l fish_prompt_pwd_dir_length 1
121	121	----> set realhome ~
421	637	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
216	216	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
41	289	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
83	83	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
165	165	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
72	316563	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
382	7529	--> set -l repo_type (_repo_type)
102	7147	---> _repo_type
30	7045	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
57	366	-----> _is_hg_repo
124	309	------> fish_print_hg_root >/dev/null
21	185	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
30	30	--------> return 1
77	6522	-----> _is_git_repo
180	2747	------> type -q git
44	44	-------> set -q argv[1]
93	93	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
164	164	-------> argparse -n type -x t,p,P $options -- $argv
6	38	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
32	32	--------> set -q _flag_help
34	34	-------> set -l res 1
32	32	-------> set -l mode normal
29	29	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
17	68	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
29	29	--------> set mode quiet
23	23	-------> set -q _flag_all
23	23	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
73	1908	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
45	45	--------> set -l found 0
34	950	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
44	44	---------> test $selection != files
7	63	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
18	809	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
640	791	----------> contains -- $i (builtin -n)
151	151	-----------> builtin -n
62	62	--------> set -l paths
22	521	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
48	48	---------> test $multi != yes
318	451	---------> set paths (command -s -- $i)
133	133	----------> command -s -- $i
56	219	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
39	39	---------> set res 0
30	30	---------> set found 1
22	22	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	72	---------> if test $multi != yes
                continue
            ...
36	36	----------> test $multi != yes
21	21	----------> continue
7	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
34	34	-------> return $res
3698	3698	------> git rev-parse --git-dir >/dev/null 2>&1
98	98	-----> echo 'git'
29	29	-----> return 0
1198	6476	--> set -l repo_branch $red(_repo_branch_name $repo_type)
100	5278	---> _repo_branch_name $repo_type
110	5178	----> _$argv[1]_branch_name
448	4352	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3904	3904	------> git symbolic-ref --quiet HEAD 2>/dev/null
90	716	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
49	49	------> set -q branch[1]
452	577	------> echo (string replace -r '^refs/heads/' '' $branch)
125	125	-------> string replace -r '^refs/heads/' '' $branch
84	84	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
22	302402	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
507	302312	---> [ (_is_repo_dirty $repo_type) ]
89	301805	----> _is_repo_dirty $repo_type
73	301716	-----> _is_$argv[1]_dirty
872	301643	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
300771	300771	-------> git status -s --ignore-submodules=dirty 2>/dev/null
42	42	---> set -l dirty "$yellow ✗"
26	26	---> set repo_info "$repo_info$dirty"
50	50	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
37	426	> fish_title
10	389	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
19	19	--> not set -q INSIDE_EMACS
259	360	--> echo (status current-command) (__fish_pwd)
22	22	---> status current-command
52	79	---> __fish_pwd
27	27	----> pwd
19087	20001	> source /home/spider/.local/share/fish/generated_completions/idlj.fish
291	291	-> complete -c idlj -s d --description 'br This is equivalent to the following line in an IDL file: . sp      .'
76	76	-> complete -c idlj -o demitAll --description 'br Emit all types, including those found in \\f3#include files.'
93	93	-> complete -c idlj -o fside --description 'br Defines what bindings to emit.'
64	64	-> complete -c idlj -s i --description 'br By default, the current directory is scanned for included files.'
50	50	-> complete -c idlj -o noWarn --description 'br Suppress warning messages.'
54	54	-> complete -c idlj -o oldImplBase --description 'br Generates skeletons compatible with pre-1. 4 JDK ORBs.'
59	59	-> complete -c idlj -o pkgPrefix --description 'br Wherever \\f3type is encountered at file scope, prefix the generated Java p…'
57	57	-> complete -c idlj -o pkgTranslate --description 'br Whenever the module name type is encountered in an identifier, replace it …'
38	38	-> complete -c idlj -o skeletonName --description 'br Use \\f3xxx%yyy as the pattern for naming the skeleton.'
33	33	-> complete -c idlj -o td --description 'br Use dir for the output directory instead of the current directory.'
31	31	-> complete -c idlj -o tieName --description 'br Use \\f3xxx%yyy according to the pattern.'
35	35	-> complete -c idlj -o nowarn -o verbose --description 'br Displays release information and terminates.'
33	33	-> complete -c idlj -o version --description '.'
74	319	> __fish_disable_bracketed_paste 'idlj ls'
245	245	-> printf "\e[?2004l"
60	1259	> fish_title idlj\ ls
17	1199	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
28	28	--> not set -q INSIDE_EMACS
857	1154	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
152	265	---> __fish_pwd
113	113	----> pwd
2613392	2613392	> idlj ls
93	231	> __fish_enable_bracketed_paste
138	138	-> printf "\e[?2004h"
88	517	> fish_mode_prompt
250	429	-> fish_default_mode_prompt
23	179	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
99	99	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
57	57	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
248	205747	> fish_prompt
125	125	-> set -l __last_command_exit_status $status
10	50	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
40	40	--> not set -q -g __fish_robbyrussell_functions_defined
10415	10655	-> set -l cyan (set_color -o cyan)
240	240	--> set_color -o cyan
396	535	-> set -l yellow (set_color -o yellow)
139	139	--> set_color -o yellow
428	502	-> set -l red (set_color -o red)
74	74	--> set_color -o red
1262	1356	-> set -l green (set_color -o green)
94	94	--> set_color -o green
334	423	-> set -l blue (set_color -o blue)
89	89	--> set_color -o blue
309	385	-> set -l normal (set_color normal)
76	76	--> set_color normal
60	60	-> set -l arrow_color "$green"
9	60	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
51	51	--> test $__last_command_exit_status != 0
54	54	-> set -l arrow "$arrow_color➜ "
9	71	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
62	62	--> test "$USER" = 'root'
486	12313	-> set -l cwd $cyan(basename (prompt_pwd))
7669	11827	--> basename (prompt_pwd)
309	4158	---> prompt_pwd
78	78	----> set -l options 'h/help'
101	101	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
9	45	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
36	36	-----> set -q _flag_help
30	30	----> set -q fish_prompt_pwd_dir_length
41	41	----> set -l fish_prompt_pwd_dir_length 1
71	71	----> set realhome ~
2922	3225	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
303	303	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
31	258	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
74	74	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
153	153	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
35	178861	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
338	23592	--> set -l repo_type (_repo_type)
111	23254	---> _repo_type
38	23143	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
65	531	-----> _is_hg_repo
263	466	------> fish_print_hg_root >/dev/null
28	203	-------> if not command -sq hg
        return 1
    ...
139	139	--------> not command -sq hg
36	36	--------> return 1
92	22443	-----> _is_git_repo
349	12538	------> type -q git
54	54	-------> set -q argv[1]
120	120	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
178	178	-------> argparse -n type -x t,p,P $options -- $argv
10	48	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
38	38	--------> set -q _flag_help
40	40	-------> set -l res 1
40	40	-------> set -l mode normal
35	35	-------> set -l multi no
35	35	-------> set -l selection all
33	33	-------> set -l short no
24	85	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
27	27	--------> set -q _flag_quiet
34	34	--------> set mode quiet
28	28	-------> set -q _flag_all
25	25	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
90	11400	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
89	89	--------> set -l found 0
53	9088	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
50	50	---------> test $selection != files
11	335	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
324	324	----------> functions -q -- $i
24	8650	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
8468	8626	----------> contains -- $i (builtin -n)
158	158	-----------> builtin -n
77	77	--------> set -l paths
34	1703	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
56	56	---------> test $multi != yes
1471	1613	---------> set paths (command -s -- $i)
142	142	----------> command -s -- $i
80	308	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
55	55	---------> set res 0
51	51	---------> set found 1
31	31	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
20	91	---------> if test $multi != yes
                continue
            ...
48	48	----------> test $multi != yes
23	23	----------> continue
8	45	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
37	37	---------> test $found = 0
44	44	-------> return $res
9813	9813	------> git rev-parse --git-dir >/dev/null 2>&1
98	98	-----> echo 'git'
33	33	-----> return 0
441	5544	--> set -l repo_branch $red(_repo_branch_name $repo_type)
106	5103	---> _repo_branch_name $repo_type
93	4997	----> _$argv[1]_branch_name
373	4409	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4036	4036	------> git symbolic-ref --quiet HEAD 2>/dev/null
27	495	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
48	48	------> set -q branch[1]
287	420	------> echo (string replace -r '^refs/heads/' '' $branch)
133	133	-------> string replace -r '^refs/heads/' '' $branch
84	84	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
18	149606	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
441	149528	---> [ (_is_repo_dirty $repo_type) ]
78	149087	----> _is_repo_dirty $repo_type
74	149009	-----> _is_$argv[1]_dirty
752	148935	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
148183	148183	-------> git status -s --ignore-submodules=dirty 2>/dev/null
35	35	---> set -l dirty "$yellow ✗"
25	25	---> set repo_info "$repo_info$dirty"
49	49	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
33	15040	> fish_title
16	15007	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
20	20	--> not set -q INSIDE_EMACS
14855	14971	--> echo (status current-command) (__fish_pwd)
18	18	---> status current-command
57	98	---> __fish_pwd
41	41	----> pwd
45	96	> __fish_disable_bracketed_paste clear
51	51	-> printf "\e[?2004l"
34	891	> fish_title clear
13	857	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
21	21	--> not set -q INSIDE_EMACS
730	823	--> echo (status current-command) (__fish_pwd)
20	20	---> status current-command
44	73	---> __fish_pwd
29	29	----> pwd
1554	1554	> clear
45	115	> __fish_enable_bracketed_paste
70	70	-> printf "\e[?2004h"
38	160	> fish_mode_prompt
49	122	-> fish_default_mode_prompt
11	73	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
20	20	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
93	161512	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
3	18	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
15	15	--> not set -q -g __fish_robbyrussell_functions_defined
154	194	-> set -l cyan (set_color -o cyan)
40	40	--> set_color -o cyan
111	145	-> set -l yellow (set_color -o yellow)
34	34	--> set_color -o yellow
3808	3833	-> set -l red (set_color -o red)
25	25	--> set_color -o red
159	209	-> set -l green (set_color -o green)
50	50	--> set_color -o green
1598	1629	-> set -l blue (set_color -o blue)
31	31	--> set_color -o blue
589	628	-> set -l normal (set_color normal)
39	39	--> set_color normal
31	31	-> set -l arrow_color "$green"
5	29	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
24	24	--> test $__last_command_exit_status != 0
22	22	-> set -l arrow "$arrow_color➜ "
3	30	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
27	27	--> test "$USER" = 'root'
538	3845	-> set -l cwd $cyan(basename (prompt_pwd))
2385	3307	--> basename (prompt_pwd)
78	922	---> prompt_pwd
27	27	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	19	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
15	15	-----> set -q _flag_help
12	12	----> set -q fish_prompt_pwd_dir_length
16	16	----> set -l fish_prompt_pwd_dir_length 1
29	29	----> set realhome ~
511	583	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
72	72	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
15	119	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
70	70	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
20	150729	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
157	5684	--> set -l repo_type (_repo_type)
55	5527	---> _repo_type
16	5472	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	185	-----> _is_hg_repo
61	156	------> fish_print_hg_root >/dev/null
13	95	-------> if not command -sq hg
        return 1
    ...
67	67	--------> not command -sq hg
15	15	--------> return 1
42	5208	-----> _is_git_repo
93	3084	------> type -q git
21	21	-------> set -q argv[1]
42	42	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
88	88	-------> argparse -n type -x t,p,P $options -- $argv
3	18	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
15	15	--------> set -q _flag_help
16	16	-------> set -l res 1
19	19	-------> set -l mode normal
15	15	-------> set -l multi no
15	15	-------> set -l selection all
14	14	-------> set -l short no
9	35	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
12	12	--------> set -q _flag_quiet
14	14	--------> set mode quiet
11	11	-------> set -q _flag_all
10	10	-------> set -q _flag_short
10	10	-------> set -q _flag_no_functions
36	2661	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
23	23	--------> set -l found 0
16	2208	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
20	20	---------> test $selection != files
5	38	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
33	33	----------> functions -q -- $i
13	2134	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
2047	2121	----------> contains -- $i (builtin -n)
74	74	-----------> builtin -n
33	33	--------> set -l paths
12	234	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
22	22	---------> test $multi != yes
134	200	---------> set paths (command -s -- $i)
66	66	----------> command -s -- $i
28	109	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
18	18	---------> set res 0
19	19	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	33	---------> if test $multi != yes
                continue
            ...
16	16	----------> test $multi != yes
10	10	----------> continue
3	18	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
15	15	---------> test $found = 0
16	16	-------> return $res
2082	2082	------> git rev-parse --git-dir >/dev/null 2>&1
50	50	-----> echo 'git'
13	13	-----> return 0
1259	12032	--> set -l repo_branch $red(_repo_branch_name $repo_type)
40	10773	---> _repo_branch_name $repo_type
52	10733	----> _$argv[1]_branch_name
2767	10029	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
7262	7262	------> git symbolic-ref --quiet HEAD 2>/dev/null
16	652	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
37	37	------> set -q branch[1]
542	599	------> echo (string replace -r '^refs/heads/' '' $branch)
57	57	-------> string replace -r '^refs/heads/' '' $branch
41	41	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
16	132952	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
312	132884	---> [ (_is_repo_dirty $repo_type) ]
40	132572	----> _is_repo_dirty $repo_type
38	132532	-----> _is_$argv[1]_dirty
642	132494	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
131852	131852	-------> git status -s --ignore-submodules=dirty 2>/dev/null
33	33	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
37	37	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
23	290	> fish_title
7	267	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
16	16	--> not set -q INSIDE_EMACS
174	244	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
37	55	---> __fish_pwd
18	18	----> pwd
102	177	> __fish_disable_bracketed_paste 'ls -alF'
75	75	-> printf "\e[?2004l"
68	874	> fish_title ls\ -alF
27	806	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
487	740	--> echo (status current-command) (__fish_pwd)
42	42	---> status current-command
73	211	---> __fish_pwd
138	138	----> pwd
426	10486	> ls -alF
409	4013	-> isatty stdout
57	57	--> set -l options 'h/help'
62	62	--> argparse -n isatty $options -- $argv
11	37	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
26	26	---> set -q _flag_help
8	33	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
25	25	---> set -q argv[2]
29	29	--> set -l fd
37	66	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
29	29	---> set fd 1
3320	3320	--> command [ -t "$fd" ]
108	108	-> set -a opt -F
5939	5939	-> command ls $opt $argv
132	271	> __fish_enable_bracketed_paste
139	139	-> printf "\e[?2004h"
95	345	> fish_mode_prompt
104	250	-> fish_default_mode_prompt
17	146	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
89	89	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
40	40	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
158	284770	> fish_prompt
97	97	-> set -l __last_command_exit_status $status
6	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
274	356	-> set -l cyan (set_color -o cyan)
82	82	--> set_color -o cyan
281	341	-> set -l yellow (set_color -o yellow)
60	60	--> set_color -o yellow
292	368	-> set -l red (set_color -o red)
76	76	--> set_color -o red
239	314	-> set -l green (set_color -o green)
75	75	--> set_color -o green
246	321	-> set -l blue (set_color -o blue)
75	75	--> set_color -o blue
262	326	-> set -l normal (set_color normal)
64	64	--> set_color normal
50	50	-> set -l arrow_color "$green"
6	46	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
40	40	--> test $__last_command_exit_status != 0
38	38	-> set -l arrow "$arrow_color➜ "
5	54	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
49	49	--> test "$USER" = 'root'
316	3518	-> set -l cwd $cyan(basename (prompt_pwd))
2123	3202	--> basename (prompt_pwd)
201	1079	---> prompt_pwd
49	49	----> set -l options 'h/help'
86	86	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	31	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
23	23	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
55	55	----> set realhome ~
270	410	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
140	140	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
24	194	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
68	68	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
102	102	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	278689	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
336	7734	--> set -l repo_type (_repo_type)
124	7398	---> _repo_type
25	7274	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
54	342	-----> _is_hg_repo
116	288	------> fish_print_hg_root >/dev/null
23	172	-------> if not command -sq hg
        return 1
    ...
123	123	--------> not command -sq hg
26	26	--------> return 1
59	6820	-----> _is_git_repo
159	3391	------> type -q git
38	38	-------> set -q argv[1]
87	87	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
170	170	-------> argparse -n type -x t,p,P $options -- $argv
6	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
28	28	--------> set -q _flag_help
82	82	-------> set -l res 1
28	28	-------> set -l mode normal
25	25	-------> set -l multi no
26	26	-------> set -l selection all
24	24	-------> set -l short no
15	62	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
21	21	--------> set -q _flag_quiet
26	26	--------> set mode quiet
21	21	-------> set -q _flag_all
20	20	-------> set -q _flag_short
20	20	-------> set -q _flag_no_functions
65	2565	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
45	45	--------> set -l found 0
32	1728	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
5	56	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
51	51	----------> functions -q -- $i
9	1599	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
1446	1590	----------> contains -- $i (builtin -n)
144	144	-----------> builtin -n
41	41	--------> set -l paths
16	446	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
37	37	---------> test $multi != yes
266	393	---------> set paths (command -s -- $i)
127	127	----------> command -s -- $i
50	208	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
36	36	---------> set res 0
40	40	---------> set found 1
20	20	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
12	62	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
19	19	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
30	30	-------> return $res
3370	3370	------> git rev-parse --git-dir >/dev/null 2>&1
67	67	-----> echo 'git'
20	20	-----> return 0
307	5125	--> set -l repo_branch $red(_repo_branch_name $repo_type)
106	4818	---> _repo_branch_name $repo_type
107	4712	----> _$argv[1]_branch_name
408	4130	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3722	3722	------> git symbolic-ref --quiet HEAD 2>/dev/null
20	475	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
46	46	------> set -q branch[1]
302	409	------> echo (string replace -r '^refs/heads/' '' $branch)
107	107	-------> string replace -r '^refs/heads/' '' $branch
62	62	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
36	265739	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
470	265627	---> [ (_is_repo_dirty $repo_type) ]
82	265157	----> _is_repo_dirty $repo_type
61	265075	-----> _is_$argv[1]_dirty
764	265014	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
264250	264250	-------> git status -s --ignore-submodules=dirty 2>/dev/null
43	43	---> set -l dirty "$yellow ✗"
33	33	---> set repo_info "$repo_info$dirty"
60	60	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
39	349	> fish_title
11	310	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
23	23	--> not set -q INSIDE_EMACS
189	276	--> echo (status current-command) (__fish_pwd)
22	22	---> status current-command
40	65	---> __fish_pwd
25	25	----> pwd
120	400	> __fish_disable_bracketed_paste clear
280	280	-> printf "\e[?2004l"
101	1534	> fish_title clear
35	1433	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
60	60	--> not set -q INSIDE_EMACS
794	1338	--> echo (status current-command) (__fish_pwd)
66	66	---> status current-command
265	478	---> __fish_pwd
213	213	----> pwd
2662	2662	> clear
92	217	> __fish_enable_bracketed_paste
125	125	-> printf "\e[?2004h"
81	477	> fish_mode_prompt
236	396	-> fish_default_mode_prompt
23	160	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
84	84	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
53	53	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
173	137558	> fish_prompt
93	93	-> set -l __last_command_exit_status $status
8	42	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
334	528	-> set -l cyan (set_color -o cyan)
194	194	--> set_color -o cyan
237	321	-> set -l yellow (set_color -o yellow)
84	84	--> set_color -o yellow
274	332	-> set -l red (set_color -o red)
58	58	--> set_color -o red
244	314	-> set -l green (set_color -o green)
70	70	--> set_color -o green
199	267	-> set -l blue (set_color -o blue)
68	68	--> set_color -o blue
259	345	-> set -l normal (set_color normal)
86	86	--> set_color normal
59	59	-> set -l arrow_color "$green"
7	72	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
65	65	--> test $__last_command_exit_status != 0
50	50	-> set -l arrow "$arrow_color➜ "
8	67	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
59	59	--> test "$USER" = 'root'
277	3507	-> set -l cwd $cyan(basename (prompt_pwd))
1829	3230	--> basename (prompt_pwd)
274	1401	---> prompt_pwd
73	73	----> set -l options 'h/help'
98	98	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
10	42	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
38	38	----> set -l fish_prompt_pwd_dir_length 1
64	64	----> set realhome ~
336	591	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
255	255	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
24	193	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
56	56	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
113	113	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
15	131353	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
214	4100	--> set -l repo_type (_repo_type)
69	3886	---> _repo_type
15	3817	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
43	353	-----> _is_hg_repo
183	310	------> fish_print_hg_root >/dev/null
17	127	-------> if not command -sq hg
        return 1
    ...
90	90	--------> not command -sq hg
20	20	--------> return 1
39	3402	-----> _is_git_repo
135	1568	------> type -q git
24	24	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
80	80	-------> argparse -n type -x t,p,P $options -- $argv
2	17	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
15	15	--------> set -q _flag_help
16	16	-------> set -l res 1
15	15	-------> set -l mode normal
14	14	-------> set -l multi no
14	14	-------> set -l selection all
13	13	-------> set -l short no
12	35	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
10	10	--------> set -q _flag_quiet
13	13	--------> set mode quiet
10	10	-------> set -q _flag_all
11	11	-------> set -q _flag_short
10	10	-------> set -q _flag_no_functions
41	1108	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
17	628	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
20	20	---------> test $selection != files
4	119	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
115	115	----------> functions -q -- $i
8	472	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
388	464	----------> contains -- $i (builtin -n)
76	76	-----------> builtin -n
29	29	--------> set -l paths
12	256	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
22	22	---------> test $multi != yes
156	222	---------> set paths (command -s -- $i)
66	66	----------> command -s -- $i
28	107	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
21	21	---------> set res 0
14	14	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	33	---------> if test $multi != yes
                continue
            ...
17	17	----------> test $multi != yes
10	10	----------> continue
3	18	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
15	15	---------> test $found = 0
16	16	-------> return $res
1795	1795	------> git rev-parse --git-dir >/dev/null 2>&1
36	36	-----> echo 'git'
11	11	-----> return 0
168	2506	--> set -l repo_branch $red(_repo_branch_name $repo_type)
42	2338	---> _repo_branch_name $repo_type
48	2296	----> _$argv[1]_branch_name
202	1997	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
1795	1795	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	251	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
21	21	------> set -q branch[1]
160	219	------> echo (string replace -r '^refs/heads/' '' $branch)
59	59	-------> string replace -r '^refs/heads/' '' $branch
36	36	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
12	124696	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
122	124635	---> [ (_is_repo_dirty $repo_type) ]
40	124513	----> _is_repo_dirty $repo_type
34	124473	-----> _is_$argv[1]_dirty
188	124439	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
124251	124251	-------> git status -s --ignore-submodules=dirty 2>/dev/null
30	30	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
29	274	> fish_title
6	245	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
15	15	--> not set -q INSIDE_EMACS
164	224	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
29	44	---> __fish_pwd
15	15	----> pwd
98	299	> __fish_disable_bracketed_paste l
201	201	-> printf "\e[?2004l"
-260452	1260	> fish_title l
28	1173	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
49	49	--> not set -q INSIDE_EMACS
702	1096	--> echo (status current-command) (__fish_pwd)
48	48	---> status current-command
195	346	---> __fish_pwd
151	151	----> pwd
63	260539	-> __fish_command_not_found_handler l
260476	260476	--> /usr/lib/command-not-found -- $argv[1]
40	77	> __fish_enable_bracketed_paste
37	37	-> printf "\e[?2004h"
21	120	> fish_mode_prompt
56	99	-> fish_default_mode_prompt
7	43	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
23	23	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
13	13	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
55	124561	> fish_prompt
24	24	-> set -l __last_command_exit_status $status
3	13	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
10	10	--> not set -q -g __fish_robbyrussell_functions_defined
106	166	-> set -l cyan (set_color -o cyan)
60	60	--> set_color -o cyan
94	122	-> set -l yellow (set_color -o yellow)
28	28	--> set_color -o yellow
120	140	-> set -l red (set_color -o red)
20	20	--> set_color -o red
101	127	-> set -l green (set_color -o green)
26	26	--> set_color -o green
87	111	-> set -l blue (set_color -o blue)
24	24	--> set_color -o blue
93	112	-> set -l normal (set_color normal)
19	19	--> set_color normal
20	20	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
15	15	--> test $__last_command_exit_status != 0
16	16	--> set arrow_color "$red"
14	14	-> set -l arrow "$arrow_color➜ "
1	15	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
14	14	--> test "$USER" = 'root'
157	1677	-> set -l cwd $cyan(basename (prompt_pwd))
1095	1520	--> basename (prompt_pwd)
73	425	---> prompt_pwd
18	18	----> set -l options 'h/help'
25	25	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
2	12	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
10	10	-----> set -q _flag_help
15	15	----> set -q fish_prompt_pwd_dir_length
16	16	----> set -l fish_prompt_pwd_dir_length 1
23	23	----> set realhome ~
103	183	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
80	80	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
6	60	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
19	19	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
35	35	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
25	121895	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
145	3516	--> set -l repo_type (_repo_type)
41	3371	---> _repo_type
18	3330	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
24	224	-----> _is_hg_repo
114	200	------> fish_print_hg_root >/dev/null
11	86	-------> if not command -sq hg
        return 1
    ...
59	59	--------> not command -sq hg
16	16	--------> return 1
45	3016	-----> _is_git_repo
129	1378	------> type -q git
20	20	-------> set -q argv[1]
39	39	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-------> argparse -n type -x t,p,P $options -- $argv
4	20	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
16	16	--------> set -q _flag_help
13	13	-------> set -l res 1
11	11	-------> set -l mode normal
9	9	-------> set -l multi no
10	10	-------> set -l selection all
9	9	-------> set -l short no
6	23	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
8	8	--------> set -q _flag_quiet
9	9	--------> set mode quiet
8	8	-------> set -q _flag_all
7	7	-------> set -q _flag_short
8	8	-------> set -q _flag_no_functions
37	982	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
11	11	--------> set -l found 0
17	508	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
14	14	---------> test $selection != files
2	86	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
84	84	----------> functions -q -- $i
6	391	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
305	385	----------> contains -- $i (builtin -n)
80	80	-----------> builtin -n
25	25	--------> set -l paths
11	250	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
24	24	---------> test $multi != yes
148	215	---------> set paths (command -s -- $i)
67	67	----------> command -s -- $i
31	127	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
21	21	---------> set res 0
18	18	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	42	---------> if test $multi != yes
                continue
            ...
21	21	----------> test $multi != yes
12	12	----------> continue
5	24	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
19	19	---------> test $found = 0
20	20	-------> return $res
1593	1593	------> git rev-parse --git-dir >/dev/null 2>&1
57	57	-----> echo 'git'
15	15	-----> return 0
136	2680	--> set -l repo_branch $red(_repo_branch_name $repo_type)
43	2544	---> _repo_branch_name $repo_type
42	2501	----> _$argv[1]_branch_name
160	2110	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
1950	1950	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	349	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
18	18	------> set -q branch[1]
262	321	------> echo (string replace -r '^refs/heads/' '' $branch)
59	59	-------> string replace -r '^refs/heads/' '' $branch
28	28	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
10	115646	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
140	115589	---> [ (_is_repo_dirty $repo_type) ]
29	115449	----> _is_repo_dirty $repo_type
26	115420	-----> _is_$argv[1]_dirty
167	115394	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
115227	115227	-------> git status -s --ignore-submodules=dirty 2>/dev/null
28	28	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
22	255	> fish_title
9	233	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
154	210	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
25	41	---> __fish_pwd
16	16	----> pwd
111	194	> __fish_disable_bracketed_paste 'ls -alF'
83	83	-> printf "\e[?2004l"
88	911	> fish_title ls\ -alF
27	823	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
45	45	--> not set -q INSIDE_EMACS
567	751	--> echo (status current-command) (__fish_pwd)
53	53	---> status current-command
80	131	---> __fish_pwd
51	51	----> pwd
587	14250	> ls -alF
681	5363	-> isatty stdout
119	119	--> set -l options 'h/help'
83	83	--> argparse -n isatty $options -- $argv
14	47	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
33	33	---> set -q _flag_help
24	93	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
69	69	---> set -q argv[2]
63	63	--> set -l fd
82	159	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
77	77	---> set fd 1
4118	4118	--> command [ -t "$fd" ]
144	144	-> set -a opt -F
8156	8156	-> command ls $opt $argv
98	236	> __fish_enable_bracketed_paste
138	138	-> printf "\e[?2004h"
141	606	> fish_mode_prompt
193	465	-> fish_default_mode_prompt
30	272	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
165	165	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
77	77	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
305	281070	> fish_prompt
127	127	-> set -l __last_command_exit_status $status
13	66	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
53	53	--> not set -q -g __fish_robbyrussell_functions_defined
710	863	-> set -l cyan (set_color -o cyan)
153	153	--> set_color -o cyan
422	578	-> set -l yellow (set_color -o yellow)
156	156	--> set_color -o yellow
336	408	-> set -l red (set_color -o red)
72	72	--> set_color -o red
295	386	-> set -l green (set_color -o green)
91	91	--> set_color -o green
296	381	-> set -l blue (set_color -o blue)
85	85	--> set_color -o blue
305	381	-> set -l normal (set_color normal)
76	76	--> set_color normal
58	58	-> set -l arrow_color "$green"
37	82	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
54	54	-> set -l arrow "$arrow_color➜ "
5	63	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
58	58	--> test "$USER" = 'root'
390	4188	-> set -l cwd $cyan(basename (prompt_pwd))
2455	3798	--> basename (prompt_pwd)
194	1343	---> prompt_pwd
104	104	----> set -l options 'h/help'
133	133	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	47	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
39	39	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
36	36	----> set -l fish_prompt_pwd_dir_length 1
62	62	----> set realhome ~
343	511	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
168	168	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
31	230	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
70	70	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
129	129	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
53	273080	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
377	10114	--> set -l repo_type (_repo_type)
99	9737	---> _repo_type
46	9638	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
79	472	-----> _is_hg_repo
195	393	------> fish_print_hg_root >/dev/null
24	198	-------> if not command -sq hg
        return 1
    ...
142	142	--------> not command -sq hg
32	32	--------> return 1
92	8930	-----> _is_git_repo
289	4604	------> type -q git
66	66	-------> set -q argv[1]
137	137	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
266	266	-------> argparse -n type -x t,p,P $options -- $argv
13	64	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
51	51	--------> set -q _flag_help
78	78	-------> set -l res 1
54	54	-------> set -l mode normal
47	47	-------> set -l multi no
48	48	-------> set -l selection all
45	45	-------> set -l short no
36	120	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
36	36	--------> set -q _flag_quiet
48	48	--------> set mode quiet
39	39	-------> set -q _flag_all
34	34	-------> set -q _flag_short
34	34	-------> set -q _flag_no_functions
119	3227	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
68	68	--------> set -l found 0
70	1850	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
65	65	---------> test $selection != files
14	112	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
98	98	----------> functions -q -- $i
23	1603	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
1245	1580	----------> contains -- $i (builtin -n)
335	335	-----------> builtin -n
92	92	--------> set -l paths
40	720	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
79	79	---------> test $multi != yes
394	601	---------> set paths (command -s -- $i)
207	207	----------> command -s -- $i
74	315	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
71	71	---------> set res 0
38	38	---------> set found 1
27	27	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
24	105	---------> if test $multi != yes
                continue
            ...
49	49	----------> test $multi != yes
32	32	----------> continue
13	63	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
50	50	---------> test $found = 0
56	56	-------> return $res
4234	4234	------> git rev-parse --git-dir >/dev/null 2>&1
138	138	-----> echo 'git'
52	52	-----> return 0
554	6973	--> set -l repo_branch $red(_repo_branch_name $repo_type)
102	6419	---> _repo_branch_name $repo_type
103	6317	----> _$argv[1]_branch_name
460	5484	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
5024	5024	------> git symbolic-ref --quiet HEAD 2>/dev/null
40	730	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
71	71	------> set -q branch[1]
408	619	------> echo (string replace -r '^refs/heads/' '' $branch)
211	211	-------> string replace -r '^refs/heads/' '' $branch
131	131	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
16	255809	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
310	255733	---> [ (_is_repo_dirty $repo_type) ]
155	255423	----> _is_repo_dirty $repo_type
101	255268	-----> _is_$argv[1]_dirty
345	255167	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
254822	254822	-------> git status -s --ignore-submodules=dirty 2>/dev/null
36	36	---> set -l dirty "$yellow ✗"
24	24	---> set repo_info "$repo_info$dirty"
50	50	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
34	334	> fish_title
10	300	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
21	21	--> not set -q INSIDE_EMACS
197	269	--> echo (status current-command) (__fish_pwd)
23	23	---> status current-command
31	49	---> __fish_pwd
18	18	----> pwd
459	76145	> __fish_complete_cd
75535	75587	-> source /usr/share/fish/functions/__fish_complete_cd.fish
52	52	--> function __fish_complete_cd -d "Completions for the cd command"
    set -q CDPATH[1]
    or return 0 # no CDPATH so rely solely on the core file name completions

    set -l token (commandline -ct)
    if string match -qr '^\.{0,2}/.*' -- $token
        # Absolute path or explicitly relative to the current directory. Rely on the builtin file
        # name completions since we no longer exclude them from the `cd` argument completion.
        return
    end

    # Relative path. Check $CDPATH and use that as the description for any possible matches.
    # We deliberately exclude the `.` path because the core file name completion logic will include
    # it when presenting possible matches.
    set -l cdpath (string match -v '.' -- $CDPATH)

    # Remove the CWD if it is in CDPATH since, again, the core file name completion logic will
    # handle it.
    set -l cdpath (string match -v -- $PWD $cdpath)
    set -q cdpath[1]
    or return 0

    # TODO: There's a subtlety regarding descriptions - if $cdpath[1]/foo and $cdpath[2]/foo
    # exist, we print both but want the first description to win - this currently works, but
    # is not guaranteed.
    for cdpath in $cdpath
        # Replace $HOME with "~".
        set -l desc (string replace -r -- "^$HOME" "~" "$cdpath")
        # This assumes the CDPATH component itself is cd-able.
        for d in $cdpath/$token*/
            # Remove the cdpath component again.
            test -x $d
            and printf "%s\tCDPATH %s\n" (string replace -r "^$cdpath/" "" -- $d) $desc
        end
    end
...
67	67	-> set -q CDPATH[1]
32	32	-> return 0
121	246	> __fish_disable_bracketed_paste 'cd src/'
125	125	-> printf "\e[?2004l"
146	1308	> fish_title cd\ src/
43	1162	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
74	74	--> not set -q INSIDE_EMACS
762	1045	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
125	228	---> __fish_pwd
103	103	----> pwd
261	4103	> cd src/
97	97	-> set -l MAX_DIR_HIST 25
23	1270	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
686	1247	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
386	386	---> count $argv
119	119	---> test "$argv[1]" = "--"
56	56	---> echo 1
18	67	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
49	49	--> status --is-command-substitution
70	70	-> set -l previous $PWD
17	80	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
63	63	--> test "$argv" = "-"
17	72	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
55	55	--> test "$argv" = "."
200	958	-> builtin cd $argv
162	758	--> __update_cwd_osc VARIABLE SET PWD
18	114	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
52	52	----> status --is-command-substitution
44	44	----> set -q INSIDE_EMACS
393	482	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
89	89	----> string escape --style=url $PWD
72	72	-> set -l cd_status $status
123	1103	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
78	78	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
29	29	--> set -q dirprev
39	39	--> set -q dirprev[$MAX_DIR_HIST]
33	33	--> set -U -q dirprev
82	82	--> set -g -a dirprev $previous
365	365	--> set -U -q dirnext
66	66	--> set -e dirnext
149	149	--> set -U -q __fish_cd_direction
139	139	--> set -g __fish_cd_direction prev
53	53	-> return $cd_status
215	311	> __fish_enable_bracketed_paste
96	96	-> printf "\e[?2004h"
71	250	> fish_mode_prompt
58	179	-> fish_default_mode_prompt
19	121	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
64	64	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
178	281906	> fish_prompt
78	78	-> set -l __last_command_exit_status $status
7	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
290	365	-> set -l cyan (set_color -o cyan)
75	75	--> set_color -o cyan
365	433	-> set -l yellow (set_color -o yellow)
68	68	--> set_color -o yellow
343	428	-> set -l red (set_color -o red)
85	85	--> set_color -o red
308	383	-> set -l green (set_color -o green)
75	75	--> set_color -o green
315	388	-> set -l blue (set_color -o blue)
73	73	--> set_color -o blue
290	362	-> set -l normal (set_color normal)
72	72	--> set_color normal
79	79	-> set -l arrow_color "$green"
10	102	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
92	92	--> test $__last_command_exit_status != 0
52	52	-> set -l arrow "$arrow_color➜ "
7	50	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
43	43	--> test "$USER" = 'root'
380	5849	-> set -l cwd $cyan(basename (prompt_pwd))
4088	5469	--> basename (prompt_pwd)
127	1381	---> prompt_pwd
53	53	----> set -l options 'h/help'
70	70	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
31	31	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
49	49	----> set realhome ~
501	677	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
176	176	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
50	308	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
83	83	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
175	175	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
39	273084	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
381	8725	--> set -l repo_type (_repo_type)
92	8344	---> _repo_type
51	8252	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
46	324	-----> _is_hg_repo
103	278	------> fish_print_hg_root >/dev/null
22	175	-------> if not command -sq hg
        return 1
    ...
123	123	--------> not command -sq hg
30	30	--------> return 1
95	7692	-----> _is_git_repo
183	2572	------> type -q git
39	39	-------> set -q argv[1]
77	77	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
143	143	-------> argparse -n type -x t,p,P $options -- $argv
5	36	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
32	32	-------> set -l res 1
32	32	-------> set -l mode normal
29	29	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
17	69	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
29	29	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
73	1775	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
33	33	--------> set -l found 0
37	839	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
41	41	---------> test $selection != files
6	65	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
59	59	----------> functions -q -- $i
10	696	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
562	686	----------> contains -- $i (builtin -n)
124	124	-----------> builtin -n
45	45	--------> set -l paths
22	520	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
41	41	---------> test $multi != yes
331	457	---------> set paths (command -s -- $i)
126	126	----------> command -s -- $i
55	227	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
47	47	---------> set res 0
30	30	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
15	72	---------> if test $multi != yes
                continue
            ...
36	36	----------> test $multi != yes
21	21	----------> continue
7	38	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
34	34	-------> return $res
5025	5025	------> git rev-parse --git-dir >/dev/null 2>&1
136	136	-----> echo 'git'
49	49	-----> return 0
386	8031	--> set -l repo_branch $red(_repo_branch_name $repo_type)
148	7645	---> _repo_branch_name $repo_type
121	7497	----> _$argv[1]_branch_name
434	6561	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
6127	6127	------> git symbolic-ref --quiet HEAD 2>/dev/null
26	815	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
48	48	------> set -q branch[1]
559	741	------> echo (string replace -r '^refs/heads/' '' $branch)
182	182	-------> string replace -r '^refs/heads/' '' $branch
82	82	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
42	256207	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
261	256113	---> [ (_is_repo_dirty $repo_type) ]
78	255852	----> _is_repo_dirty $repo_type
64	255774	-----> _is_$argv[1]_dirty
309	255710	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
255401	255401	-------> git status -s --ignore-submodules=dirty 2>/dev/null
30	30	---> set -l dirty "$yellow ✗"
22	22	---> set repo_info "$repo_info$dirty"
37	37	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
27	333	> fish_title
8	306	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
15	15	--> not set -q INSIDE_EMACS
200	283	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
37	67	---> __fish_pwd
30	30	----> pwd
131	245	> __fish_disable_bracketed_paste 'ls -alF'
114	114	-> printf "\e[?2004l"
131	2226	> fish_title ls\ -alF
50	2095	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
67	67	--> not set -q INSIDE_EMACS
1682	1978	--> echo (status current-command) (__fish_pwd)
62	62	---> status current-command
139	234	---> __fish_pwd
95	95	----> pwd
449	16762	> ls -alF
464	4583	-> isatty stdout
152	152	--> set -l options 'h/help'
122	122	--> argparse -n isatty $options -- $argv
24	81	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
57	57	---> set -q _flag_help
25	82	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
57	57	---> set -q argv[2]
63	63	--> set -l fd
74	140	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
66	66	---> set fd 1
3479	3479	--> command [ -t "$fd" ]
132	132	-> set -a opt -F
11598	11598	-> command ls $opt $argv
141	321	> __fish_enable_bracketed_paste
180	180	-> printf "\e[?2004h"
128	583	> fish_mode_prompt
186	455	-> fish_default_mode_prompt
31	269	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
166	166	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
72	72	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
243	326486	> fish_prompt
116	116	-> set -l __last_command_exit_status $status
7	42	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
35	35	--> not set -q -g __fish_robbyrussell_functions_defined
361	454	-> set -l cyan (set_color -o cyan)
93	93	--> set_color -o cyan
401	490	-> set -l yellow (set_color -o yellow)
89	89	--> set_color -o yellow
398	482	-> set -l red (set_color -o red)
84	84	--> set_color -o red
304	396	-> set -l green (set_color -o green)
92	92	--> set_color -o green
328	414	-> set -l blue (set_color -o blue)
86	86	--> set_color -o blue
326	409	-> set -l normal (set_color normal)
83	83	--> set_color normal
52	52	-> set -l arrow_color "$green"
7	51	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
44	44	--> test $__last_command_exit_status != 0
43	43	-> set -l arrow "$arrow_color➜ "
6	72	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
66	66	--> test "$USER" = 'root'
472	7768	-> set -l cwd $cyan(basename (prompt_pwd))
5910	7296	--> basename (prompt_pwd)
197	1386	---> prompt_pwd
73	73	----> set -l options 'h/help'
96	96	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
56	56	----> set realhome ~
389	666	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
277	277	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
27	201	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
62	62	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
112	112	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
47	315420	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
439	25761	--> set -l repo_type (_repo_type)
131	25322	---> _repo_type
50	25191	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
61	388	-----> _is_hg_repo
134	327	------> fish_print_hg_root >/dev/null
24	193	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
31	31	--------> return 1
126	24566	-----> _is_git_repo
288	15703	------> type -q git
52	52	-------> set -q argv[1]
86	86	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
239	239	-------> argparse -n type -x t,p,P $options -- $argv
16	77	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
61	61	--------> set -q _flag_help
85	85	-------> set -l res 1
980	980	-------> set -l mode normal
50	50	-------> set -l multi no
33	33	-------> set -l selection all
29	29	-------> set -l short no
21	78	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
31	31	--------> set mode quiet
26	26	-------> set -q _flag_all
77	77	-------> set -q _flag_short
57	57	-------> set -q _flag_no_functions
115	13487	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
85	85	--------> set -l found 0
59	11562	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
73	73	---------> test $selection != files
11	107	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
96	96	----------> functions -q -- $i
22	11323	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
10986	11301	----------> contains -- $i (builtin -n)
315	315	-----------> builtin -n
70	70	--------> set -l paths
55	1061	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
87	87	---------> test $multi != yes
723	919	---------> set paths (command -s -- $i)
196	196	----------> command -s -- $i
109	521	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
70	70	---------> set res 0
160	160	---------> set found 1
46	46	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
32	136	---------> if test $multi != yes
                continue
            ...
69	69	----------> test $multi != yes
35	35	----------> continue
13	73	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
60	60	---------> test $found = 0
59	59	-------> return $res
8737	8737	------> git rev-parse --git-dir >/dev/null 2>&1
138	138	-----> echo 'git'
49	49	-----> return 0
441	13554	--> set -l repo_branch $red(_repo_branch_name $repo_type)
150	13113	---> _repo_branch_name $repo_type
164	12963	----> _$argv[1]_branch_name
497	11988	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11491	11491	------> git symbolic-ref --quiet HEAD 2>/dev/null
39	811	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
91	91	------> set -q branch[1]
465	681	------> echo (string replace -r '^refs/heads/' '' $branch)
216	216	-------> string replace -r '^refs/heads/' '' $branch
116	116	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
12	275942	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
399	275885	---> [ (_is_repo_dirty $repo_type) ]
139	275486	----> _is_repo_dirty $repo_type
110	275347	-----> _is_$argv[1]_dirty
367	275237	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
274870	274870	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
34	34	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
29	303	> fish_title
7	274	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
15	15	--> not set -q INSIDE_EMACS
191	252	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
28	45	---> __fish_pwd
17	17	----> pwd
14739	16840	> source /usr/share/fish/completions/python3.fish
366	366	-> complete -c python3 -s B -d 'Don\'t write .py[co] files on import'
88	88	-> complete -c python3 -s c -x -d "Execute argument as command"
70	70	-> complete -c python3 -s d -d "Debug on"
73	73	-> complete -c python3 -s E -d "Ignore environment variables"
73	73	-> complete -c python3 -s h -l help -d "Display help and exit"
69	69	-> complete -c python3 -s i -d "Interactive mode after executing commands"
61	61	-> complete -c python3 -s O -d "Enable optimizations"
70	70	-> complete -c python3 -o OO -d "Remove doc-strings in addition to the -O optimizations"
64	64	-> complete -c python3 -s s -d 'Don\'t add user site directory to sys.path'
61	61	-> complete -c python3 -s S -d "Disable import of site module"
66	66	-> complete -c python3 -s u -d "Unbuffered input and output"
63	63	-> complete -c python3 -s v -d "Verbose mode"
57	57	-> complete -c python3 -s V -d "Display version and exit"
158	158	-> complete -c python3 -s W -x -d "Warning control" -a "ignore default all module once error"
80	80	-> complete -c python3 -s x -d 'Skip first line of source, allowing use of non-Unix forms of #!cmd'
144	144	-> complete -c python3 -n '__fish_is_first_token' -fa "(__fish_complete_suffix .py)"
124	124	-> complete -c python3 -f -n '__fish_is_first_token' -a '-' -d 'Read program from stdin'
71	71	-> complete -c python3 -s q -d 'Don\'t print version and copyright messages on interactive startup'
55	55	-> complete -c python3 -s X -x -d 'Set implementation-specific option'
57	57	-> complete -c python3 -s b -d 'Issue warnings about str(bytes_instance), str(bytearray_instance) and comparing bytes/bytearray with str'
53	53	-> complete -c python3 -o bb -d 'Issue errors'
178	178	-> complete -c python3 -s m -d 'Run library module as a script (terminates option list)' -xa '(python3 -c "import pkgutil; print(\'\n\'.join([p[1] for p in pkgutil.iter_modules()]))")'
139	440	> __fish_disable_bracketed_paste 'python3 manage.py createsuperuser admin'
301	301	-> printf "\e[?2004l"
132	2393	> fish_title python3\ manage.py\ createsuperuser\ admin
38	2261	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
83	83	--> not set -q INSIDE_EMACS
1384	2140	--> echo (status current-command) (__fish_pwd)
83	83	---> status current-command
419	673	---> __fish_pwd
254	254	----> pwd
4527979	4527979	> python3 manage.py createsuperuser admin
117	310	> __fish_enable_bracketed_paste
193	193	-> printf "\e[?2004h"
120	740	> fish_mode_prompt
358	620	-> fish_default_mode_prompt
29	262	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
161	161	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
72	72	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
186	168777	> fish_prompt
135	135	-> set -l __last_command_exit_status $status
12	53	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
41	41	--> not set -q -g __fish_robbyrussell_functions_defined
318	582	-> set -l cyan (set_color -o cyan)
264	264	--> set_color -o cyan
519	597	-> set -l yellow (set_color -o yellow)
78	78	--> set_color -o yellow
258	326	-> set -l red (set_color -o red)
68	68	--> set_color -o red
140	182	-> set -l green (set_color -o green)
42	42	--> set_color -o green
129	167	-> set -l blue (set_color -o blue)
38	38	--> set_color -o blue
149	191	-> set -l normal (set_color normal)
42	42	--> set_color normal
46	46	-> set -l arrow_color "$green"
12	87	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
34	34	--> test $__last_command_exit_status != 0
41	41	--> set arrow_color "$red"
23	23	-> set -l arrow "$arrow_color➜ "
3	26	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
23	23	--> test "$USER" = 'root'
186	2414	-> set -l cwd $cyan(basename (prompt_pwd))
1332	2228	--> basename (prompt_pwd)
136	896	---> prompt_pwd
29	29	----> set -l options 'h/help'
50	50	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	18	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
15	15	-----> set -q _flag_help
13	13	----> set -q fish_prompt_pwd_dir_length
17	17	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
218	350	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
132	132	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
15	250	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
30	30	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
205	205	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	163698	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
221	7473	--> set -l repo_type (_repo_type)
65	7252	---> _repo_type
20	7187	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
40	288	-----> _is_hg_repo
153	248	------> fish_print_hg_root >/dev/null
12	95	-------> if not command -sq hg
        return 1
    ...
68	68	--------> not command -sq hg
15	15	--------> return 1
45	6803	-----> _is_git_repo
168	4196	------> type -q git
23	23	-------> set -q argv[1]
44	44	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
89	89	-------> argparse -n type -x t,p,P $options -- $argv
3	19	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
16	16	--------> set -q _flag_help
17	17	-------> set -l res 1
16	16	-------> set -l mode normal
35	35	-------> set -l multi no
26	26	-------> set -l selection all
16	16	-------> set -l short no
8	35	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
12	12	--------> set -q _flag_quiet
15	15	--------> set mode quiet
12	12	-------> set -q _flag_all
11	11	-------> set -q _flag_short
11	11	-------> set -q _flag_no_functions
564	3649	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
22	2375	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
22	22	---------> test $selection != files
3	131	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
128	128	----------> functions -q -- $i
11	2200	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
2099	2189	----------> contains -- $i (builtin -n)
90	90	-----------> builtin -n
78	78	--------> set -l paths
20	396	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
42	42	---------> test $multi != yes
232	334	---------> set paths (command -s -- $i)
102	102	----------> command -s -- $i
49	177	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
25	25	---------> set found 1
19	19	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
13	55	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
15	15	----------> continue
5	29	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
24	24	---------> test $found = 0
25	25	-------> return $res
2562	2562	------> git rev-parse --git-dir >/dev/null 2>&1
58	58	-----> echo 'git'
18	18	-----> return 0
207	2710	--> set -l repo_branch $red(_repo_branch_name $repo_type)
47	2503	---> _repo_branch_name $repo_type
49	2456	----> _$argv[1]_branch_name
195	2134	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
1939	1939	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	273	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
23	23	------> set -q branch[1]
175	238	------> echo (string replace -r '^refs/heads/' '' $branch)
63	63	-------> string replace -r '^refs/heads/' '' $branch
37	37	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
18	153460	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
194	153374	---> [ (_is_repo_dirty $repo_type) ]
46	153180	----> _is_repo_dirty $repo_type
46	153134	-----> _is_$argv[1]_dirty
267	153088	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
152821	152821	-------> git status -s --ignore-submodules=dirty 2>/dev/null
39	39	---> set -l dirty "$yellow ✗"
29	29	---> set repo_info "$repo_info$dirty"
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
43	409	> fish_title
13	366	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
24	24	--> not set -q INSIDE_EMACS
235	329	--> echo (status current-command) (__fish_pwd)
23	23	---> status current-command
41	71	---> __fish_pwd
30	30	----> pwd
953	3135	> up-or-search
833	898	-> source /usr/share/fish/functions/up-or-search.fish
65	65	--> function up-or-search -d "Depending on cursor position and current mode, either search backward or move up one line"
    # If we are already in search mode, continue
    if commandline --search-mode
        commandline -f history-search-backward
        return
    end

    # If we are navigating the pager, then up always navigates
    if commandline --paging-mode
        commandline -f up-line
        return
    end

    # We are not already in search mode.
    # If we are on the top line, start search mode,
    # otherwise move up
    set lineno (commandline -L)

    switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    end
...
25	314	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
289	289	--> commandline --search-mode
19	83	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
64	64	--> commandline --paging-mode
634	728	-> set lineno (commandline -L)
94	94	--> commandline -L
63	159	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
96	96	--> commandline -f history-search-backward
145	274	> __fish_disable_bracketed_paste 'python3 manage.py createsuperuser '
129	129	-> printf "\e[?2004l"
121	1297	> fish_title python3\ manage.py\ createsuperuser\ 
39	1176	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
83	83	--> not set -q INSIDE_EMACS
784	1054	--> echo (status current-command) (__fish_pwd)
76	76	---> status current-command
128	194	---> __fish_pwd
66	66	----> pwd
1198170	1198170	> python3 manage.py createsuperuser
99	338	> __fish_enable_bracketed_paste
239	239	-> printf "\e[?2004h"
106	399	> fish_mode_prompt
127	293	-> fish_default_mode_prompt
24	166	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
95	95	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
47	47	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
196	170742	> fish_prompt
102	102	-> set -l __last_command_exit_status $status
9	47	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
38	38	--> not set -q -g __fish_robbyrussell_functions_defined
332	433	-> set -l cyan (set_color -o cyan)
101	101	--> set_color -o cyan
276	355	-> set -l yellow (set_color -o yellow)
79	79	--> set_color -o yellow
309	379	-> set -l red (set_color -o red)
70	70	--> set_color -o red
282	357	-> set -l green (set_color -o green)
75	75	--> set_color -o green
280	349	-> set -l blue (set_color -o blue)
69	69	--> set_color -o blue
289	359	-> set -l normal (set_color normal)
70	70	--> set_color normal
59	59	-> set -l arrow_color "$green"
25	142	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
52	52	--> test $__last_command_exit_status != 0
65	65	--> set arrow_color "$red"
71	71	-> set -l arrow "$arrow_color➜ "
11	92	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
81	81	--> test "$USER" = 'root'
314	2819	-> set -l cwd $cyan(basename (prompt_pwd))
1394	2505	--> basename (prompt_pwd)
184	1111	---> prompt_pwd
75	75	----> set -l options 'h/help'
117	117	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
9	46	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
37	37	-----> set -q _flag_help
32	32	----> set -q fish_prompt_pwd_dir_length
41	41	----> set -l fish_prompt_pwd_dir_length 1
65	65	----> set realhome ~
269	405	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
136	136	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
17	146	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
42	42	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
87	87	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
20	164947	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
301	7389	--> set -l repo_type (_repo_type)
51	7088	---> _repo_type
17	7037	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
36	239	-----> _is_hg_repo
82	203	------> fish_print_hg_root >/dev/null
19	121	-------> if not command -sq hg
        return 1
    ...
80	80	--------> not command -sq hg
22	22	--------> return 1
51	6714	-----> _is_git_repo
127	4335	------> type -q git
33	33	-------> set -q argv[1]
72	72	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
102	102	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
18	18	-------> set -l res 1
16	16	-------> set -l mode normal
14	14	-------> set -l multi no
14	14	-------> set -l selection all
13	13	-------> set -l short no
11	35	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
10	10	--------> set -q _flag_quiet
14	14	--------> set mode quiet
12	12	-------> set -q _flag_all
11	11	-------> set -q _flag_short
10	10	-------> set -q _flag_no_functions
41	3801	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
19	668	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
23	23	---------> test $selection != files
5	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
46	46	----------> functions -q -- $i
7	575	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
480	568	----------> contains -- $i (builtin -n)
88	88	-----------> builtin -n
28	28	--------> set -l paths
17	2806	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
21	21	---------> test $multi != yes
2702	2768	---------> set paths (command -s -- $i)
66	66	----------> command -s -- $i
55	181	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
38	38	---------> set res 0
32	32	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	41	---------> if test $multi != yes
                continue
            ...
22	22	----------> test $multi != yes
11	11	----------> continue
7	45	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
38	38	---------> test $found = 0
28	28	-------> return $res
2328	2328	------> git rev-parse --git-dir >/dev/null 2>&1
54	54	-----> echo 'git'
13	13	-----> return 0
196	9686	--> set -l repo_branch $red(_repo_branch_name $repo_type)
50	9490	---> _repo_branch_name $repo_type
62	9440	----> _$argv[1]_branch_name
233	4593	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
4360	4360	------> git symbolic-ref --quiet HEAD 2>/dev/null
27	4785	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
37	37	------> set -q branch[1]
4626	4721	------> echo (string replace -r '^refs/heads/' '' $branch)
95	95	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	147809	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
218	147750	---> [ (_is_repo_dirty $repo_type) ]
43	147532	----> _is_repo_dirty $repo_type
34	147489	-----> _is_$argv[1]_dirty
188	147455	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
147267	147267	-------> git status -s --ignore-submodules=dirty 2>/dev/null
29	29	---> set -l dirty "$yellow ✗"
17	17	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
30	292	> fish_title
11	262	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
24	24	--> not set -q INSIDE_EMACS
165	227	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
29	46	---> __fish_pwd
17	17	----> pwd
179	949	> up-or-search
29	147	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
118	118	--> commandline --search-mode
18	89	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
71	71	--> commandline --paging-mode
384	451	-> set lineno (commandline -L)
67	67	--> commandline -L
37	83	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
46	46	--> commandline -f history-search-backward
166	575	> __fish_disable_bracketed_paste 'python3 manage.py createsuperuser'
409	409	-> printf "\e[?2004l"
111	1264	> fish_title python3\ manage.py\ createsuperuser
39	1153	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
56	56	--> not set -q INSIDE_EMACS
682	1058	--> echo (status current-command) (__fish_pwd)
50	50	---> status current-command
189	326	---> __fish_pwd
137	137	----> pwd
820645	820645	> python3 manage.py createsuperuser
64	141	> __fish_enable_bracketed_paste
77	77	-> printf "\e[?2004h"
60	368	> fish_mode_prompt
196	308	-> fish_default_mode_prompt
14	112	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
64	64	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
131	126513	> fish_prompt
67	67	-> set -l __last_command_exit_status $status
5	28	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
23	23	--> not set -q -g __fish_robbyrussell_functions_defined
197	354	-> set -l cyan (set_color -o cyan)
157	157	--> set_color -o cyan
1171	1224	-> set -l yellow (set_color -o yellow)
53	53	--> set_color -o yellow
858	912	-> set -l red (set_color -o red)
54	54	--> set_color -o red
155	201	-> set -l green (set_color -o green)
46	46	--> set_color -o green
112	138	-> set -l blue (set_color -o blue)
26	26	--> set_color -o blue
113	140	-> set -l normal (set_color normal)
27	27	--> set_color normal
22	22	-> set -l arrow_color "$green"
7	50	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
18	18	--> test $__last_command_exit_status != 0
25	25	--> set arrow_color "$red"
16	16	-> set -l arrow "$arrow_color➜ "
2	19	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
17	17	--> test "$USER" = 'root'
212	9723	-> set -l cwd $cyan(basename (prompt_pwd))
8632	9511	--> basename (prompt_pwd)
227	879	---> prompt_pwd
47	47	----> set -l options 'h/help'
64	64	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	23	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
18	18	-----> set -q _flag_help
14	14	----> set -q fish_prompt_pwd_dir_length
29	29	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
183	316	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
133	133	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
16	122	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
74	74	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13	113453	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
153	4328	--> set -l repo_type (_repo_type)
62	4175	---> _repo_type
11	4113	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
36	289	-----> _is_hg_repo
148	253	------> fish_print_hg_root >/dev/null
14	105	-------> if not command -sq hg
        return 1
    ...
74	74	--------> not command -sq hg
17	17	--------> return 1
40	3769	-----> _is_git_repo
171	2292	------> type -q git
29	29	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
115	115	-------> argparse -n type -x t,p,P $options -- $argv
5	54	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
49	49	--------> set -q _flag_help
20	20	-------> set -l res 1
19	19	-------> set -l mode normal
18	18	-------> set -l multi no
20	20	-------> set -l selection all
17	17	-------> set -l short no
9	41	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
14	14	--------> set -q _flag_quiet
18	18	--------> set mode quiet
14	14	-------> set -q _flag_all
13	13	-------> set -q _flag_short
12	12	-------> set -q _flag_no_functions
39	1678	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
23	1086	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
23	23	---------> test $selection != files
5	153	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
148	148	----------> functions -q -- $i
10	887	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
780	877	----------> contains -- $i (builtin -n)
97	97	-----------> builtin -n
32	32	--------> set -l paths
14	328	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
26	26	---------> test $multi != yes
218	288	---------> set paths (command -s -- $i)
70	70	----------> command -s -- $i
32	137	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
26	26	---------> set res 0
21	21	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
10	43	---------> if test $multi != yes
                continue
            ...
22	22	----------> test $multi != yes
11	11	----------> continue
5	24	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
19	19	---------> test $found = 0
20	20	-------> return $res
1437	1437	------> git rev-parse --git-dir >/dev/null 2>&1
34	34	-----> echo 'git'
10	10	-----> return 0
117	1801	--> set -l repo_branch $red(_repo_branch_name $repo_type)
32	1684	---> _repo_branch_name $repo_type
34	1652	----> _$argv[1]_branch_name
125	1435	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
1310	1310	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	183	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
15	15	------> set -q branch[1]
115	159	------> echo (string replace -r '^refs/heads/' '' $branch)
44	44	-------> string replace -r '^refs/heads/' '' $branch
24	24	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
11	107287	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
120	107232	---> [ (_is_repo_dirty $repo_type) ]
32	107112	----> _is_repo_dirty $repo_type
33	107080	-----> _is_$argv[1]_dirty
225	107047	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
106822	106822	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
17	17	---> set repo_info "$repo_info$dirty"
35	35	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
31	397	> fish_title
10	366	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
24	24	--> not set -q INSIDE_EMACS
267	332	--> echo (status current-command) (__fish_pwd)
19	19	---> status current-command
29	46	---> __fish_pwd
17	17	----> pwd
109	642	> up-or-search
19	81	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
62	62	--> commandline --search-mode
9	42	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
33	33	--> commandline --paging-mode
289	344	-> set lineno (commandline -L)
55	55	--> commandline -L
31	66	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
35	35	--> commandline -f history-search-backward
102	205	> __fish_disable_bracketed_paste cd
103	103	-> printf "\e[?2004l"
87	1026	> fish_title cd
26	939	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
53	53	--> not set -q INSIDE_EMACS
670	860	--> echo (status current-command) (__fish_pwd)
54	54	---> status current-command
85	136	---> __fish_pwd
51	51	----> pwd
344	2787	> cd
59	59	-> set -l MAX_DIR_HIST 25
16	758	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
435	742	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
189	189	---> count $argv
76	76	---> test "$argv[1]" = "--"
42	42	---> echo 1
10	44	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
34	34	--> status --is-command-substitution
57	57	-> set -l previous $PWD
11	50	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
39	39	--> test "$argv" = "-"
30	76	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
46	46	--> test "$argv" = "."
206	817	-> builtin cd $argv
91	611	--> __update_cwd_osc VARIABLE SET PWD
12	76	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
33	33	----> status --is-command-substitution
31	31	----> set -q INSIDE_EMACS
352	444	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
92	92	----> string escape --style=url $PWD
93	93	-> set -l cd_status $status
74	439	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
78	78	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
29	29	--> set -q dirprev
39	39	--> set -q dirprev[$MAX_DIR_HIST]
25	25	--> set -U -q dirprev
71	71	--> set -g -a dirprev $previous
28	28	--> set -U -q dirnext
27	27	--> set -e dirnext
24	24	--> set -U -q __fish_cd_direction
44	44	--> set -g __fish_cd_direction prev
50	50	-> return $cd_status
69	166	> __fish_enable_bracketed_paste
97	97	-> printf "\e[?2004h"
73	250	> fish_mode_prompt
67	177	-> fish_default_mode_prompt
16	110	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
56	56	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
256	38314	> fish_prompt
64	64	-> set -l __last_command_exit_status $status
6	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
355	429	-> set -l cyan (set_color -o cyan)
74	74	--> set_color -o cyan
383	467	-> set -l yellow (set_color -o yellow)
84	84	--> set_color -o yellow
352	451	-> set -l red (set_color -o red)
99	99	--> set_color -o red
2103	2203	-> set -l green (set_color -o green)
100	100	--> set_color -o green
580	707	-> set -l blue (set_color -o blue)
127	127	--> set_color -o blue
397	502	-> set -l normal (set_color normal)
105	105	--> set_color normal
62	62	-> set -l arrow_color "$green"
7	54	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
47	47	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
6	48	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
42	42	--> test "$USER" = 'root'
502	8937	-> set -l cwd $cyan(basename (prompt_pwd))
5576	8435	--> basename (prompt_pwd)
249	2859	---> prompt_pwd
89	89	----> set -l options 'h/help'
121	121	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
14	73	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
59	59	-----> set -q _flag_help
46	46	----> set -q fish_prompt_pwd_dir_length
64	64	----> set -l fish_prompt_pwd_dir_length 1
93	93	----> set realhome ~
1585	1781	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
196	196	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
45	343	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
104	104	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
194	194	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	23853	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
453	23835	--> set -l repo_type (_repo_type)
133	23382	---> _repo_type
26	23172	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
106	575	-----> _is_hg_repo
183	469	------> fish_print_hg_root >/dev/null
42	286	-------> if not command -sq hg
        return 1
    ...
193	193	--------> not command -sq hg
51	51	--------> return 1
138	22571	-----> _is_git_repo
325	14747	------> type -q git
70	70	-------> set -q argv[1]
149	149	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
279	279	-------> argparse -n type -x t,p,P $options -- $argv
15	73	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
58	58	--------> set -q _flag_help
61	61	-------> set -l res 1
68	68	-------> set -l mode normal
64	64	-------> set -l multi no
61	61	-------> set -l selection all
63	63	-------> set -l short no
46	155	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
46	46	--------> set -q _flag_quiet
63	63	--------> set mode quiet
51	51	-------> set -q _flag_all
48	48	-------> set -q _flag_short
46	46	-------> set -q _flag_no_functions
110	13185	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
74	74	--------> set -l found 0
80	11404	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
82	82	---------> test $selection != files
15	134	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
119	119	----------> functions -q -- $i
22	11108	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
10837	11086	----------> contains -- $i (builtin -n)
249	249	-----------> builtin -n
68	68	--------> set -l paths
31	1117	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
51	51	---------> test $multi != yes
897	1035	---------> set paths (command -s -- $i)
138	138	----------> command -s -- $i
62	367	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
46	46	---------> set res 0
33	33	---------> set found 1
23	23	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
19	203	---------> if test $multi != yes
                continue
            ...
156	156	----------> test $multi != yes
28	28	----------> continue
7	45	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
38	38	---------> test $found = 0
49	49	-------> return $res
7686	7686	------> git rev-parse --git-dir >/dev/null 2>&1
77	77	----> return 1
199	199	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
114	1289	> fish_title
39	1175	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
72	72	--> not set -q INSIDE_EMACS
689	1064	--> echo (status current-command) (__fish_pwd)
72	72	---> status current-command
199	303	---> __fish_pwd
104	104	----> pwd
101	204	> __fish_disable_bracketed_paste clear
103	103	-> printf "\e[?2004l"
86	1067	> fish_title clear
31	981	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
51	51	--> not set -q INSIDE_EMACS
670	899	--> echo (status current-command) (__fish_pwd)
58	58	---> status current-command
107	171	---> __fish_pwd
64	64	----> pwd
3597	3597	> clear
75	204	> __fish_enable_bracketed_paste
129	129	-> printf "\e[?2004h"
129	541	> fish_mode_prompt
194	412	-> fish_default_mode_prompt
26	218	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
112	112	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
80	80	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
552	25784	> fish_prompt
330	330	-> set -l __last_command_exit_status $status
11	68	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
57	57	--> not set -q -g __fish_robbyrussell_functions_defined
807	966	-> set -l cyan (set_color -o cyan)
159	159	--> set_color -o cyan
373	454	-> set -l yellow (set_color -o yellow)
81	81	--> set_color -o yellow
303	365	-> set -l red (set_color -o red)
62	62	--> set_color -o red
251	370	-> set -l green (set_color -o green)
119	119	--> set_color -o green
543	617	-> set -l blue (set_color -o blue)
74	74	--> set_color -o blue
357	457	-> set -l normal (set_color normal)
100	100	--> set_color normal
309	309	-> set -l arrow_color "$green"
12	83	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
71	71	--> test $__last_command_exit_status != 0
69	69	-> set -l arrow "$arrow_color➜ "
9	74	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
65	65	--> test "$USER" = 'root'
493	10517	-> set -l cwd $cyan(basename (prompt_pwd))
8499	10024	--> basename (prompt_pwd)
202	1525	---> prompt_pwd
90	90	----> set -l options 'h/help'
110	110	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	42	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
34	34	-----> set -q _flag_help
30	30	----> set -q fish_prompt_pwd_dir_length
40	40	----> set -l fish_prompt_pwd_dir_length 1
69	69	----> set realhome ~
455	636	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
181	181	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
31	306	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
61	61	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
214	214	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13	10417	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
704	10404	--> set -l repo_type (_repo_type)
157	9700	---> _repo_type
22	9473	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
96	502	-----> _is_hg_repo
159	406	------> fish_print_hg_root >/dev/null
35	247	-------> if not command -sq hg
        return 1
    ...
173	173	--------> not command -sq hg
39	39	--------> return 1
110	8949	-----> _is_git_repo
314	4183	------> type -q git
67	67	-------> set -q argv[1]
132	132	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
254	254	-------> argparse -n type -x t,p,P $options -- $argv
11	60	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
49	49	--------> set -q _flag_help
48	48	-------> set -l res 1
48	48	-------> set -l mode normal
42	42	-------> set -l multi no
43	43	-------> set -l selection all
40	40	-------> set -l short no
31	110	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
34	34	--------> set -q _flag_quiet
45	45	--------> set mode quiet
40	40	-------> set -q _flag_all
32	32	-------> set -q _flag_short
32	32	-------> set -q _flag_no_functions
154	2864	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
78	78	--------> set -l found 0
61	1389	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
59	59	---------> test $selection != files
12	133	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
121	121	----------> functions -q -- $i
22	1136	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
875	1114	----------> contains -- $i (builtin -n)
239	239	-----------> builtin -n
88	88	--------> set -l paths
32	675	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
68	68	---------> test $multi != yes
382	575	---------> set paths (command -s -- $i)
193	193	----------> command -s -- $i
92	411	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
77	77	---------> set res 0
73	73	---------> set found 1
41	41	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
28	128	---------> if test $multi != yes
                continue
            ...
65	65	----------> test $multi != yes
35	35	----------> continue
12	69	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
57	57	---------> test $found = 0
57	57	-------> return $res
4656	4656	------> git rev-parse --git-dir >/dev/null 2>&1
70	70	----> return 1
136	136	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
85	3428	> fish_title
36	3343	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
55	55	--> not set -q INSIDE_EMACS
2973	3252	--> echo (status current-command) (__fish_pwd)
45	45	---> status current-command
159	234	---> __fish_pwd
75	75	----> pwd
115	208	> __fish_disable_bracketed_paste 'cd Documents/FitMe/'
93	93	-> printf "\e[?2004l"
78	989	> fish_title cd\ Documents/FitMe/
25	911	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
650	838	--> echo (status current-command) (__fish_pwd)
54	54	---> status current-command
87	134	---> __fish_pwd
47	47	----> pwd
179	3235	> cd Documents/FitMe/
51	51	-> set -l MAX_DIR_HIST 25
29	1070	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
740	1041	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
100	100	---> count $argv
111	111	---> test "$argv[1]" = "--"
90	90	---> echo 1
22	74	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
52	52	--> status --is-command-substitution
99	99	-> set -l previous $PWD
24	100	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
76	76	--> test "$argv" = "-"
24	97	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
73	73	--> test "$argv" = "."
255	1041	-> builtin cd $argv
127	786	--> __update_cwd_osc VARIABLE SET PWD
13	83	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
38	38	----> status --is-command-substitution
32	32	----> set -q INSIDE_EMACS
473	576	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
103	103	----> string escape --style=url $PWD
73	73	-> set -l cd_status $status
67	413	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
81	81	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
30	30	--> set -q dirprev
41	41	--> set -q dirprev[$MAX_DIR_HIST]
25	25	--> set -U -q dirprev
50	50	--> set -g -a dirprev $previous
23	23	--> set -U -q dirnext
28	28	--> set -e dirnext
24	24	--> set -U -q __fish_cd_direction
44	44	--> set -g __fish_cd_direction prev
38	38	-> return $cd_status
54	120	> __fish_enable_bracketed_paste
66	66	-> printf "\e[?2004h"
66	295	> fish_mode_prompt
75	229	-> fish_default_mode_prompt
18	154	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
98	98	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
203	286725	> fish_prompt
70	70	-> set -l __last_command_exit_status $status
5	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
406	500	-> set -l cyan (set_color -o cyan)
94	94	--> set_color -o cyan
249	317	-> set -l yellow (set_color -o yellow)
68	68	--> set_color -o yellow
301	376	-> set -l red (set_color -o red)
75	75	--> set_color -o red
279	361	-> set -l green (set_color -o green)
82	82	--> set_color -o green
297	390	-> set -l blue (set_color -o blue)
93	93	--> set_color -o blue
353	415	-> set -l normal (set_color normal)
62	62	--> set_color normal
99	99	-> set -l arrow_color "$green"
13	85	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
72	72	--> test $__last_command_exit_status != 0
79	79	-> set -l arrow "$arrow_color➜ "
16	92	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
76	76	--> test "$USER" = 'root'
447	5739	-> set -l cwd $cyan(basename (prompt_pwd))
4099	5292	--> basename (prompt_pwd)
141	1193	---> prompt_pwd
55	55	----> set -l options 'h/help'
80	80	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	40	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
93	93	----> set -l fish_prompt_pwd_dir_length 1
65	65	----> set realhome ~
327	486	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
159	159	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
24	206	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
60	60	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
122	122	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
47	277927	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
361	11912	--> set -l repo_type (_repo_type)
121	11551	---> _repo_type
38	11430	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
68	365	-----> _is_hg_repo
113	297	------> fish_print_hg_root >/dev/null
22	184	-------> if not command -sq hg
        return 1
    ...
132	132	--------> not command -sq hg
30	30	--------> return 1
81	10880	-----> _is_git_repo
232	3947	------> type -q git
49	49	-------> set -q argv[1]
78	78	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
200	200	-------> argparse -n type -x t,p,P $options -- $argv
11	62	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
51	51	--------> set -q _flag_help
50	50	-------> set -l res 1
50	50	-------> set -l mode normal
48	48	-------> set -l multi no
145	145	-------> set -l selection all
59	59	-------> set -l short no
33	118	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
38	38	--------> set -q _flag_quiet
47	47	--------> set mode quiet
42	42	-------> set -q _flag_all
35	35	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
89	2719	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
37	37	--------> set -l found 0
63	1327	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
47	47	---------> test $selection != files
14	105	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
91	91	----------> functions -q -- $i
22	1112	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
944	1090	----------> contains -- $i (builtin -n)
146	146	-----------> builtin -n
116	116	--------> set -l paths
35	713	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
80	80	---------> test $multi != yes
401	598	---------> set paths (command -s -- $i)
197	197	----------> command -s -- $i
114	397	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
71	71	---------> set res 0
76	76	---------> set found 1
45	45	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
19	91	---------> if test $multi != yes
                continue
            ...
50	50	----------> test $multi != yes
22	22	----------> continue
7	40	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
33	33	---------> test $found = 0
37	37	-------> return $res
6852	6852	------> git rev-parse --git-dir >/dev/null 2>&1
106	106	-----> echo 'git'
41	41	-----> return 0
430	5425	--> set -l repo_branch $red(_repo_branch_name $repo_type)
85	4995	---> _repo_branch_name $repo_type
91	4910	----> _$argv[1]_branch_name
344	4249	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
3905	3905	------> git symbolic-ref --quiet HEAD 2>/dev/null
25	570	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
45	45	------> set -q branch[1]
354	500	------> echo (string replace -r '^refs/heads/' '' $branch)
146	146	-------> string replace -r '^refs/heads/' '' $branch
121	121	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	260422	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
246	260364	---> [ (_is_repo_dirty $repo_type) ]
93	260118	----> _is_repo_dirty $repo_type
63	260025	-----> _is_$argv[1]_dirty
317	259962	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
259645	259645	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
36	36	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
23	314	> fish_title
10	291	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
14	14	--> not set -q INSIDE_EMACS
211	267	--> echo (status current-command) (__fish_pwd)
16	16	---> status current-command
23	40	---> __fish_pwd
17	17	----> pwd
123	225	> __fish_disable_bracketed_paste 'ls -alF'
102	102	-> printf "\e[?2004l"
100	4025	> fish_title ls\ -alF
46	3925	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
47	47	--> not set -q INSIDE_EMACS
3573	3832	--> echo (status current-command) (__fish_pwd)
68	68	---> status current-command
115	191	---> __fish_pwd
76	76	----> pwd
499	15586	> ls -alF
484	5641	-> isatty stdout
70	70	--> set -l options 'h/help'
74	74	--> argparse -n isatty $options -- $argv
14	44	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
30	30	---> set -q _flag_help
11	40	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
29	29	---> set -q argv[2]
34	34	--> set -l fd
43	76	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
33	33	---> set fd 1
4819	4819	--> command [ -t "$fd" ]
113	113	-> set -a opt -F
9333	9333	-> command ls $opt $argv
122	290	> __fish_enable_bracketed_paste
168	168	-> printf "\e[?2004h"
113	432	> fish_mode_prompt
145	319	-> fish_default_mode_prompt
21	174	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
108	108	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
45	45	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
262	273244	> fish_prompt
125	125	-> set -l __last_command_exit_status $status
7	41	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
842	987	-> set -l cyan (set_color -o cyan)
145	145	--> set_color -o cyan
536	691	-> set -l yellow (set_color -o yellow)
155	155	--> set_color -o yellow
425	553	-> set -l red (set_color -o red)
128	128	--> set_color -o red
374	505	-> set -l green (set_color -o green)
131	131	--> set_color -o green
2388	2486	-> set -l blue (set_color -o blue)
98	98	--> set_color -o blue
10179	10298	-> set -l normal (set_color normal)
119	119	--> set_color normal
74	74	-> set -l arrow_color "$green"
12	72	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
60	60	--> test $__last_command_exit_status != 0
82	82	-> set -l arrow "$arrow_color➜ "
13	144	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
131	131	--> test "$USER" = 'root'
674	6710	-> set -l cwd $cyan(basename (prompt_pwd))
3186	6036	--> basename (prompt_pwd)
748	2850	---> prompt_pwd
114	114	----> set -l options 'h/help'
207	207	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
9	54	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
45	45	-----> set -q _flag_help
47	47	----> set -q fish_prompt_pwd_dir_length
241	241	----> set -l fish_prompt_pwd_dir_length 1
117	117	----> set realhome ~
680	937	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
257	257	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
54	385	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
116	116	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
215	215	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
66	250163	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
1861	12695	--> set -l repo_type (_repo_type)
160	10834	---> _repo_type
52	10674	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
90	584	-----> _is_hg_repo
205	494	------> fish_print_hg_root >/dev/null
43	289	-------> if not command -sq hg
        return 1
    ...
199	199	--------> not command -sq hg
47	47	--------> return 1
109	9805	-----> _is_git_repo
336	4681	------> type -q git
59	59	-------> set -q argv[1]
158	158	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
281	281	-------> argparse -n type -x t,p,P $options -- $argv
13	62	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
49	49	--------> set -q _flag_help
51	51	-------> set -l res 1
50	50	-------> set -l mode normal
46	46	-------> set -l multi no
47	47	-------> set -l selection all
45	45	-------> set -l short no
30	115	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
36	36	--------> set -q _flag_quiet
49	49	--------> set mode quiet
41	41	-------> set -q _flag_all
35	35	-------> set -q _flag_short
33	33	-------> set -q _flag_no_functions
119	3266	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
84	84	--------> set -l found 0
89	1690	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
71	71	---------> test $selection != files
12	101	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
89	89	----------> functions -q -- $i
27	1429	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
1133	1402	----------> contains -- $i (builtin -n)
269	269	-----------> builtin -n
94	94	--------> set -l paths
35	832	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
72	72	---------> test $multi != yes
524	725	---------> set paths (command -s -- $i)
201	201	----------> command -s -- $i
89	379	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
63	63	---------> set res 0
60	60	---------> set found 1
41	41	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
30	126	---------> if test $multi != yes
                continue
            ...
61	61	----------> test $multi != yes
35	35	----------> continue
14	68	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
54	54	---------> test $found = 0
56	56	-------> return $res
5015	5015	------> git rev-parse --git-dir >/dev/null 2>&1
181	181	-----> echo 'git'
52	52	-----> return 0
3634	11483	--> set -l repo_branch $red(_repo_branch_name $repo_type)
181	7849	---> _repo_branch_name $repo_type
159	7668	----> _$argv[1]_branch_name
662	6766	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
6104	6104	------> git symbolic-ref --quiet HEAD 2>/dev/null
40	743	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
70	70	------> set -q branch[1]
446	633	------> echo (string replace -r '^refs/heads/' '' $branch)
187	187	-------> string replace -r '^refs/heads/' '' $branch
134	134	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
22	225785	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
340	225690	---> [ (_is_repo_dirty $repo_type) ]
140	225350	----> _is_repo_dirty $repo_type
118	225210	-----> _is_$argv[1]_dirty
413	225092	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
224679	224679	-------> git status -s --ignore-submodules=dirty 2>/dev/null
44	44	---> set -l dirty "$yellow ✗"
29	29	---> set repo_info "$repo_info$dirty"
51	51	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
46	448	> fish_title
13	402	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
27	27	--> not set -q INSIDE_EMACS
257	362	--> echo (status current-command) (__fish_pwd)
25	25	---> status current-command
49	80	---> __fish_pwd
31	31	----> pwd
62	172	> __fish_disable_bracketed_paste 'cd src/'
110	110	-> printf "\e[?2004l"
48	1018	> fish_title cd\ src/
16	970	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
27	27	--> not set -q INSIDE_EMACS
715	927	--> echo (status current-command) (__fish_pwd)
27	27	---> status current-command
113	185	---> __fish_pwd
72	72	----> pwd
92	1328	> cd src/
40	40	-> set -l MAX_DIR_HIST 25
9	373	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
231	364	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
56	56	---> count $argv
50	50	---> test "$argv[1]" = "--"
27	27	---> echo 1
6	23	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
17	17	--> status --is-command-substitution
31	31	-> set -l previous $PWD
7	29	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
22	22	--> test "$argv" = "-"
5	24	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
19	19	--> test "$argv" = "."
94	446	-> builtin cd $argv
43	352	--> __update_cwd_osc VARIABLE SET PWD
6	39	---> if status --is-command-substitution || set -q INSIDE_EMACS
                return
            ...
18	18	----> status --is-command-substitution
15	15	----> set -q INSIDE_EMACS
169	270	---> printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
101	101	----> string escape --style=url $PWD
47	47	-> set -l cd_status $status
35	204	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
40	40	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
15	15	--> set -q dirprev
21	21	--> set -q dirprev[$MAX_DIR_HIST]
13	13	--> set -U -q dirprev
25	25	--> set -g -a dirprev $previous
12	12	--> set -U -q dirnext
13	13	--> set -e dirnext
12	12	--> set -U -q __fish_cd_direction
18	18	--> set -g __fish_cd_direction prev
19	19	-> return $cd_status
39	86	> __fish_enable_bracketed_paste
47	47	-> printf "\e[?2004h"
36	183	> fish_mode_prompt
91	147	-> fish_default_mode_prompt
8	56	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
30	30	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
18	18	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
88	185154	> fish_prompt
35	35	-> set -l __last_command_exit_status $status
3	18	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
15	15	--> not set -q -g __fish_robbyrussell_functions_defined
121	207	-> set -l cyan (set_color -o cyan)
86	86	--> set_color -o cyan
189	223	-> set -l yellow (set_color -o yellow)
34	34	--> set_color -o yellow
140	171	-> set -l red (set_color -o red)
31	31	--> set_color -o red
188	218	-> set -l green (set_color -o green)
30	30	--> set_color -o green
168	211	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
147	178	-> set -l normal (set_color normal)
31	31	--> set_color normal
29	29	-> set -l arrow_color "$green"
4	26	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
22	22	--> test $__last_command_exit_status != 0
22	22	-> set -l arrow "$arrow_color➜ "
3	24	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
21	21	--> test "$USER" = 'root'
172	2240	-> set -l cwd $cyan(basename (prompt_pwd))
1496	2068	--> basename (prompt_pwd)
124	572	---> prompt_pwd
27	27	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	18	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
15	15	-----> set -q _flag_help
13	13	----> set -q fish_prompt_pwd_dir_length
17	17	----> set -l fish_prompt_pwd_dir_length 1
24	24	----> set realhome ~
155	220	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
65	65	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	90	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
28	28	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
52	52	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
21	181420	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
208	6155	--> set -l repo_type (_repo_type)
45	5947	---> _repo_type
16	5902	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
23	231	-----> _is_hg_repo
121	208	------> fish_print_hg_root >/dev/null
12	87	-------> if not command -sq hg
        return 1
    ...
61	61	--------> not command -sq hg
14	14	--------> return 1
53	5581	-----> _is_git_repo
172	2806	------> type -q git
25	25	-------> set -q argv[1]
38	38	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-------> argparse -n type -x t,p,P $options -- $argv
3	19	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
16	16	--------> set -q _flag_help
16	16	-------> set -l res 1
16	16	-------> set -l mode normal
32	32	-------> set -l multi no
18	18	-------> set -l selection all
13	13	-------> set -l short no
9	35	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
11	11	--------> set -q _flag_quiet
15	15	--------> set mode quiet
12	12	-------> set -q _flag_all
11	11	-------> set -q _flag_short
10	10	-------> set -q _flag_no_functions
34	2301	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
17	17	--------> set -l found 0
24	1768	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
21	21	---------> test $selection != files
4	130	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
126	126	----------> functions -q -- $i
11	1593	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
1307	1582	----------> contains -- $i (builtin -n)
275	275	-----------> builtin -n
33	33	--------> set -l paths
12	313	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
24	24	---------> test $multi != yes
185	277	---------> set paths (command -s -- $i)
92	92	----------> command -s -- $i
29	117	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
23	23	---------> set res 0
16	16	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	37	---------> if test $multi != yes
                continue
            ...
19	19	----------> test $multi != yes
11	11	----------> continue
3	19	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
16	16	---------> test $found = 0
18	18	-------> return $res
2722	2722	------> git rev-parse --git-dir >/dev/null 2>&1
59	59	-----> echo 'git'
15	15	-----> return 0
179	7871	--> set -l repo_branch $red(_repo_branch_name $repo_type)
60	7692	---> _repo_branch_name $repo_type
60	7632	----> _$argv[1]_branch_name
186	2278	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
2092	2092	------> git symbolic-ref --quiet HEAD 2>/dev/null
144	5294	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
41	41	------> set -q branch[1]
5043	5109	------> echo (string replace -r '^refs/heads/' '' $branch)
66	66	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
13	167330	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
185	167261	---> [ (_is_repo_dirty $repo_type) ]
50	167076	----> _is_repo_dirty $repo_type
41	167026	-----> _is_$argv[1]_dirty
220	166985	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
166765	166765	-------> git status -s --ignore-submodules=dirty 2>/dev/null
33	33	---> set -l dirty "$yellow ✗"
23	23	---> set repo_info "$repo_info$dirty"
44	44	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
30	339	> fish_title
11	309	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
21	21	--> not set -q INSIDE_EMACS
201	277	--> echo (status current-command) (__fish_pwd)
19	19	---> status current-command
37	57	---> __fish_pwd
20	20	----> pwd
160	335	> __fish_disable_bracketed_paste 'python3 manage.py createsuperuser'
175	175	-> printf "\e[?2004l"
133	2009	> fish_title python3\ manage.py\ createsuperuser
40	1876	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
66	66	--> not set -q INSIDE_EMACS
1485	1770	--> echo (status current-command) (__fish_pwd)
82	82	---> status current-command
126	203	---> __fish_pwd
77	77	----> pwd
815637	815637	> python3 manage.py createsuperuser
46	110	> __fish_enable_bracketed_paste
64	64	-> printf "\e[?2004h"
48	175	> fish_mode_prompt
62	127	-> fish_default_mode_prompt
8	65	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
38	38	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
19	19	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
113	116488	> fish_prompt
51	51	-> set -l __last_command_exit_status $status
2	16	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
14	14	--> not set -q -g __fish_robbyrussell_functions_defined
160	200	-> set -l cyan (set_color -o cyan)
40	40	--> set_color -o cyan
175	208	-> set -l yellow (set_color -o yellow)
33	33	--> set_color -o yellow
145	176	-> set -l red (set_color -o red)
31	31	--> set_color -o red
165	207	-> set -l green (set_color -o green)
42	42	--> set_color -o green
130	173	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
170	216	-> set -l normal (set_color normal)
46	46	--> set_color normal
40	40	-> set -l arrow_color "$green"
12	83	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
42	42	--> set arrow_color "$red"
30	30	-> set -l arrow "$arrow_color➜ "
5	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
246	1898	-> set -l cwd $cyan(basename (prompt_pwd))
1113	1652	--> basename (prompt_pwd)
91	539	---> prompt_pwd
34	34	----> set -l options 'h/help'
46	46	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	15	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
12	12	-----> set -q _flag_help
11	11	----> set -q fish_prompt_pwd_dir_length
14	14	----> set -l fish_prompt_pwd_dir_length 1
25	25	----> set realhome ~
146	211	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
65	65	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
13	92	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
26	26	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
53	53	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
13	113006	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
141	3426	--> set -l repo_type (_repo_type)
52	3285	---> _repo_type
13	3233	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	170	-----> _is_hg_repo
53	140	------> fish_print_hg_root >/dev/null
11	87	-------> if not command -sq hg
        return 1
    ...
57	57	--------> not command -sq hg
19	19	--------> return 1
45	2997	-----> _is_git_repo
94	1319	------> type -q git
26	26	-------> set -q argv[1]
36	36	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
72	72	-------> argparse -n type -x t,p,P $options -- $argv
4	16	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
12	12	--------> set -q _flag_help
14	14	-------> set -l res 1
13	13	-------> set -l mode normal
12	12	-------> set -l multi no
12	12	-------> set -l selection all
11	11	-------> set -l short no
7	27	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
9	9	--------> set -q _flag_quiet
11	11	--------> set mode quiet
10	10	-------> set -q _flag_all
12	12	-------> set -q _flag_short
12	12	-------> set -q _flag_no_functions
34	939	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
27	476	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
44	44	---------> test $selection != files
4	37	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
33	33	----------> functions -q -- $i
5	368	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
291	363	----------> contains -- $i (builtin -n)
72	72	-----------> builtin -n
29	29	--------> set -l paths
11	253	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
18	18	---------> test $multi != yes
168	224	---------> set paths (command -s -- $i)
56	56	----------> command -s -- $i
25	105	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
23	23	---------> set res 0
19	19	---------> set found 1
9	9	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	29	---------> if test $multi != yes
                continue
            ...
16	16	----------> test $multi != yes
8	8	----------> continue
2	15	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
13	13	---------> test $found = 0
13	13	-------> return $res
1633	1633	------> git rev-parse --git-dir >/dev/null 2>&1
42	42	-----> echo 'git'
11	11	-----> return 0
129	2470	--> set -l repo_branch $red(_repo_branch_name $repo_type)
35	2341	---> _repo_branch_name $repo_type
39	2306	----> _$argv[1]_branch_name
224	2062	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
1838	1838	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	205	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
18	18	------> set -q branch[1]
126	177	------> echo (string replace -r '^refs/heads/' '' $branch)
51	51	-------> string replace -r '^refs/heads/' '' $branch
28	28	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
11	107069	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
181	107012	---> [ (_is_repo_dirty $repo_type) ]
38	106831	----> _is_repo_dirty $repo_type
44	106793	-----> _is_$argv[1]_dirty
226	106749	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
106523	106523	-------> git status -s --ignore-submodules=dirty 2>/dev/null
27	27	---> set -l dirty "$yellow ✗"
19	19	---> set repo_info "$repo_info$dirty"
36	36	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
28	429	> fish_title
10	401	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
18	18	--> not set -q INSIDE_EMACS
305	373	--> echo (status current-command) (__fish_pwd)
15	15	---> status current-command
26	53	---> __fish_pwd
27	27	----> pwd
129	423	> __fish_disable_bracketed_paste clear
294	294	-> printf "\e[?2004l"
111	1561	> fish_title clear
37	1450	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
65	65	--> not set -q INSIDE_EMACS
882	1348	--> echo (status current-command) (__fish_pwd)
72	72	---> status current-command
238	394	---> __fish_pwd
156	156	----> pwd
4453	4453	> clear
117	304	> __fish_enable_bracketed_paste
187	187	-> printf "\e[?2004h"
106	634	> fish_mode_prompt
322	528	-> fish_default_mode_prompt
23	206	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
130	130	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
53	53	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
296	311186	> fish_prompt
171	171	-> set -l __last_command_exit_status $status
13	66	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
53	53	--> not set -q -g __fish_robbyrussell_functions_defined
866	1101	-> set -l cyan (set_color -o cyan)
235	235	--> set_color -o cyan
476	652	-> set -l yellow (set_color -o yellow)
176	176	--> set_color -o yellow
416	511	-> set -l red (set_color -o red)
95	95	--> set_color -o red
361	489	-> set -l green (set_color -o green)
128	128	--> set_color -o green
340	436	-> set -l blue (set_color -o blue)
96	96	--> set_color -o blue
376	468	-> set -l normal (set_color normal)
92	92	--> set_color normal
83	83	-> set -l arrow_color "$green"
15	88	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
73	73	--> test $__last_command_exit_status != 0
87	87	-> set -l arrow "$arrow_color➜ "
13	118	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
105	105	--> test "$USER" = 'root'
479	35779	-> set -l cwd $cyan(basename (prompt_pwd))
32766	35300	--> basename (prompt_pwd)
572	2534	---> prompt_pwd
124	124	----> set -l options 'h/help'
167	167	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
13	63	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
50	50	-----> set -q _flag_help
47	47	----> set -q fish_prompt_pwd_dir_length
63	63	----> set -l fish_prompt_pwd_dir_length 1
136	136	----> set realhome ~
512	1005	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
493	493	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
50	357	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
99	99	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
208	208	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
45	270803	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
469	17722	--> set -l repo_type (_repo_type)
126	17253	---> _repo_type
51	17127	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
74	744	-----> _is_hg_repo
326	670	------> fish_print_hg_root >/dev/null
48	344	-------> if not command -sq hg
        return 1
    ...
242	242	--------> not command -sq hg
54	54	--------> return 1
120	16146	-----> _is_git_repo
440	8971	------> type -q git
55	55	-------> set -q argv[1]
94	94	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
237	237	-------> argparse -n type -x t,p,P $options -- $argv
12	65	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
53	53	--------> set -q _flag_help
57	57	-------> set -l res 1
58	58	-------> set -l mode normal
62	62	-------> set -l multi no
96	96	-------> set -l selection all
64	64	-------> set -l short no
35	135	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
44	44	--------> set -q _flag_quiet
56	56	--------> set mode quiet
51	51	-------> set -q _flag_all
50	50	-------> set -q _flag_short
44	44	-------> set -q _flag_no_functions
148	7397	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
84	84	--------> set -l found 0
83	2532	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
75	75	---------> test $selection != files
19	626	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
607	607	----------> functions -q -- $i
23	1748	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
1521	1725	----------> contains -- $i (builtin -n)
204	204	-----------> builtin -n
88	88	--------> set -l paths
68	3962	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
74	74	---------> test $multi != yes
3594	3820	---------> set paths (command -s -- $i)
226	226	----------> command -s -- $i
120	505	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
98	98	---------> set res 0
93	93	---------> set found 1
50	50	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
34	144	---------> if test $multi != yes
                continue
            ...
72	72	----------> test $multi != yes
38	38	----------> continue
14	78	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
64	64	---------> test $found = 0
66	66	-------> return $res
7055	7055	------> git rev-parse --git-dir >/dev/null 2>&1
142	142	-----> echo 'git'
44	44	-----> return 0
484	11863	--> set -l repo_branch $red(_repo_branch_name $repo_type)
127	11379	---> _repo_branch_name $repo_type
138	11252	----> _$argv[1]_branch_name
704	10314	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9610	9610	------> git symbolic-ref --quiet HEAD 2>/dev/null
37	800	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
67	67	------> set -q branch[1]
451	696	------> echo (string replace -r '^refs/heads/' '' $branch)
245	245	-------> string replace -r '^refs/heads/' '' $branch
123	123	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
15	241050	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
649	240991	---> [ (_is_repo_dirty $repo_type) ]
1241	240342	----> _is_repo_dirty $repo_type
128	239101	-----> _is_$argv[1]_dirty
629	238973	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
238344	238344	-------> git status -s --ignore-submodules=dirty 2>/dev/null
26	26	---> set -l dirty "$yellow ✗"
18	18	---> set repo_info "$repo_info$dirty"
38	38	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
29	345	> fish_title
7	316	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
19	19	--> not set -q INSIDE_EMACS
226	290	--> echo (status current-command) (__fish_pwd)
17	17	---> status current-command
27	47	---> __fish_pwd
20	20	----> pwd
96	198	> __fish_disable_bracketed_paste exit
102	102	-> printf "\e[?2004l"
82	1063	> fish_title exit
36	981	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
63	63	--> not set -q INSIDE_EMACS
666	882	--> echo (status current-command) (__fish_pwd)
69	69	---> status current-command
92	147	---> __fish_pwd
55	55	----> pwd
307	307	> exit
109	250	> __fish_disable_bracketed_paste 0
141	141	-> printf "\e[?2004l"
